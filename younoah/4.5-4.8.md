## 4.5 `new` 연산자와 생성자 함수

클래스처럼 **객체를 생성**해내는 **함수**이다.



### 생성자 함수

- 함수 이름의 첫 글자는 대문자로 시작한다.
- 반드시 `new` 연산자를 붙여 **실행**한다.

```js
function User(name) {
    // this = {}; (빈 객체가 암시적으로 만들어진다.)
    this.name = name;
    this.isAdmin = false;
    this.sayHi = function() {
    	console.log( "My name is: " + this.name );
  	};
    
    // return this; (this가 암시적으로 반환된다.)
}

const user = new User('Jack');

console.log(user.name);
console.log(user.isAdmin);

// 아래코드와 동일하게 동작한다.
const user = {
  name: "Jack",
  isAdmin: false,
  sayHi: function() {
  	console.log( "My name is: " + this.name );
  };
};
```

생성자 함수는 객체를 생성하는 것이기 때문에 `this` 에 프로퍼티(그리고 메서드)를 정의해주어야한다.



**생성자 함수 동작**

1. 빈 객체를 만들어 `this` 를 할당한다.
2. 함수 본문을 실행한다. `this` 에 새로운 프로퍼티를 추가해 `this` 를 수정한다.
3. `this` 를 반환한다.



> **주의**
>
> 모든 함수는 생성자 함수가 될 수 있다. 따라서 `new` 키워드를 사용하면 **생성자 함수 동작** 알고리즘이 실행된다.\
>
> 첫글자가 대문자인 함수는 `new` 키워드를 사용하여 실행하는 것이 공동의 약속이다.



### new.target

```js
function User() {
  alert(new.target);
}

// "new" 없이 호출
User(); // undefined

//"new"를 붙여 호출
new User(); // function User { ... }

// new.target을 이용해 생성자 함수인척 만들수 있다.
function User(name) {
  if (!new.target) { // new 없이 호출해도
    return new User(name); // new를 붙여줍니다.
  }
  this.name = name;
}

let john = User("John"); // 'new User'를 쓴 것처럼 바꿔줍니다.
alert(john.name); // John
```

함수가 `new` 와 함께 호출된다면 함수 내부에서 `new.target` 값이 해당 함수로 할당된다.



### 생성자와 return문

반환해야 할 것들이 모두 `this` 에 저장되어 자동으로 반환되기 때문에 생성자 함수는 `return` 문이 없다. 따라서 일반적으로 생성자함수에는 `return` 문을 작성하지 않는다.

만약 return문이 있다면

- 객체 리턴시, `this` 대신 리턴
- 원형 리턴시, 리턴문 무시



> **생성자 함수 호출시 괄호 생략하기**
>
> 전달할 인자가 없는 생성자 함수는 괄호를 생략할 수 있다.
>
> ```js
> // 아래 코드는 동일하게 작동한다.
> const user = new User;
> const user = new User();
> ```





## 4.6 옵셔널 체이닝 `?.`

옵셔널 체이닝을 사용하면 **객체**와 **객체의 프로퍼티** 에 안전하게 접근할 수 있다.

`?.` 앞의 평가 대상이 `undefined` 이거나 `null` 일 경우 그 즉시 평가를 멈추고 `undefined` 를 반환한다.

즉, 값이 없으면 종료, 값이 있다면 계속해서 접근해 나아간다.

- 옵셔널 체이닐을 사용하지 않으면 **에러**가 발생한다.

- 옵셔널 체이닝을 사용하면 `undefined` 를 반환 받기 때문에 **예외처리**로 이어서 작성할 수 있다.



```js
// 객체의 프로퍼티 접근 에러 예시

// 예시1, 객체
const user = {};
console.log(user.address.street);
// TypeError: Cannot read property

// 예시2, dom요소
let html = document.querySelector('.my-element').innerHTML;
// TypeError: Cannot read property

// 예시1 해결
// &&을 이용한 안전접근 , 코드가 길어진다.
console.log( user && user.address && user.address.street );
// undefined

// 옵셔널 체이닝 이용
console.log( user?.address?.street );
// undefined
```



> 옵셔널 체이닝은 존재하지 않아도 괜찮은 대상, 즉 존재하지 않을수도 있는 대상에만 사용해야한다.
>
> 무조건 값이 존재하는 대상에 사용하면, 조기에 에러를 발견하지 못할수 있다.



### 단락평가

단락평가란 평가를 진행하다 값이 없으면 그 즉시 종료하는 방식을 말한다.

옵셔널 체이닝은 대상이 존재하지 않는다면 그 즉시 종료하는 단락평가이다.



### `?.()` 와. `?.[]`

`?.()` : 옵셔널 체이닝을 이용해서 객체의 메서드가 존재하는지 확인후 실행

`?.()` : 객체의 인덱싱 가능한 대상이 있는지 확인하고 인덱싱

```js
let user1 = {
  admin() {
    alert("관리자 계정입니다.");
  }
}

let user2 = {};

user1.admin?.(); // 관리자 계정입니다.
user2.admin?.();
```



```js
let user1 = {
  firstName: "Violet"
};

let user2 = null; // user2는 권한이 없는 사용자라고 가정해봅시다.

let key = "firstName";

alert( user1?.[key] ); // Violet
alert( user2?.[key] ); // undefined

alert( user1?.[key]?.something?.not?.existing); // undefined
```



> `?.` 은 **읽기**나 **삭제**에 **사용 가능**
>
> 단 **쓰기**에는 **사용 불가**
>
> ```js
> // 읽기는 위의 예제로 대체
> 
> // 삭제
> delete user?.name // user가 존재하면 name을 삭제한다.
> 
> // 쓰기
> user?.name = 'john'; //SyntaxError
> // 에러가 발생하는 이유는 undefined = "Violet"이 되기때문
> ```



## 4.7 심볼형



## 4.8 객체를 원시형으로 변환하기