#### 2.7 형 변환(type conversion)

> **❗우선, 자바스크립트 튜토리얼에서는 **형 변환**을 <u>type conversion</u>이란 명칭을 사용 했지만, 웹 및 타 문서에서는 <u>type casting</u>이란 용어로도 사용하고 있어 관련 용어가 잘못 혼용되고 있는 게 아닐까란 생각이 들어 정확한 의미를 아래 키워드를 통해 찾아보았다.**
>
> > **`What is the difference between type conversion and type casting [in javascript]?`**
> >
> > **1. Type Casting:** 타입 캐스팅의 경우 프로그램 설계 중에 프로그래머가 해당 언어의 캐스팅 연산자를 사용하여 기존 데이터 유형을 다른 데이터 유형으로 의도적으로 변환하는 작업
> >
> > **2.Type conversion**: 타입 컨버젼의 경우 데이터 타입이 컴파일러 또는 인터프리터 등을 통해 컴파일러타임, 런타임을 통해 자동으로 다른 데이터 타입으로 변환되는 작업. 그렇기에 대상 데이터 타입은 변경되는 타입보다 작을 수 없으므로 확장 변환(widening conversion)이라고도 한다. 그리고 가장 중요한 점은 서로 호환이 가능한 데이터 타입에만 적용할 수 있다.

##### 문자형으로 변환

> 문자형으로의 형 변환은 문자형의 값이 필요할 때 일어나는데, `alert`메서드는 매개변수로 문자형을 받기 때문에, `alert(value)`에서 value는 문자형이어야 한다. 만약, 다른 형의 값을 전달받으면 이 값은 문자형으로 자동 변환된다. 그리고, `String(value)` 함수를 호출해 전달받은 값을 문자열로 변환 할 수도 있다.

```javascript
let value = true;
alert(typeof value); // boolean

value = String(value); // 변수 value엔 문자열 "true"가 저장된다.
alert(typeof value); // string
```

**`false`는 문자열 `"false"`로, `null`은 문자열 `"null"`로 변환되는 것과 같이, 문자형으로의 변환은 대부분 예측 가능한 방식으로 일어난다.**



##### 숫자형으로 변환

```javascript
숫자으로의 변환은 수학과 관련된 함수와 표현식에서 자동으로 일어난다.
alert( "6" / "2" ); // 3, 문자열이 숫자형으로 자동변환된 후 연산이 수행된다.

Number(value) 함수를 사용하면 주어진 값(value)을 숫자형으로 명시해서 변환할 수 있다.
let str = "123";
alert(typeof str); // string

let num = Number(str); // 문자열 "123"이 숫자 123으로 변환된다.

alert(typeof num); // number


숫자형 값를 사용해 무언가를 하려고 하는데 그 값을 문자 기반 폼(form)을 통해 입력받는 경우엔, 이런 명시적 형 변환이 필수인데 숫자 이외의 글자가 들어가 있는 문자열을 숫자형으로 변환하려고 하면, 그 결과는 NaN이 된다.

let age = Number("임의의 문자열 123");

alert(age); // NaN, 형 변환이 실패된다.
```

아래는, 숫자형으로 변환 시에 적용되는 규칙을 정리해보았다.

| 전달받은 값      | 형 변환 후                                                   |
| :--------------- | :----------------------------------------------------------- |
| `undefined`      | `NaN`                                                        |
| `null`           | `0`                                                          |
| `true and false` | `1` 과 `0`                                                   |
| `string`         | 문자열의 처음과 끝 공백이 제거되며, 공백 제거 후 남아있는 문자열이 없다면 `0`, 그렇지 않다면 문자열에서 숫자를 읽는다. 또, 변환에 실패하면 `NaN`이 된다. |

```javascript
alert( Number("   123   ") ); // 123
alert( Number("123z") );      // NaN ("z"를 숫자로 변환하는 데 실패함)
alert( Number(true) );        // 1
alert( Number(false) );       // 0

`null과 undefined은 숫자형으로 변환 시 결과가 다르다는 점에 유의하시기 바랍니다. null은 0이 되고 undefined는 NaN이 된다.`
```



##### 불린형으로 변환

`Boolean(value)`를 호출하면 명시적으로 불리언으로의 형 변환을 수행할 수 있으며, 불린형으로 변환 시 적용되는 규칙은 아래와 같다.

> 숫자 `0`, 빈 문자열, `null`, `undefined`, `NaN`과 같이 직관적으로도 “비어있다고” 느껴지는 값들은 `false`가 되며, 그 외의 값은 `true`로 변환된다.

```javascript
alert( Boolean(1) ); // 숫자 1(true)
alert( Boolean(0) ); // 숫자 0(false)

alert( Boolean("hello") ); // 문자열(true)
alert( Boolean("") ); // 빈 문자열(false)

`주의: 문자열 "0"은 true이다!!`
alert( Boolean("0") ); // true
alert( Boolean(" ") ); // 공백이 있는 문자열도 비어있지 않은 문자열이기 때문에 true로 변환된다.
```



##### 정리

문자, 숫자, 논리형으로의 형 변환은 자주 일어나는 형 변환이다.

**`문자형으로 변환`** 은 무언가를 출력할 때 주로 일어난다. `String(value)`을 사용하면 문자형으로 명시적 변환이 가능하다. 원시 자료형을 문자형으로 변환할 땐, 대부분 그 결과를 예상할 수 있을 정도로 명시적인 방식으로 일어난다.

**`숫자형으로 변환`**은 수학 관련 연산시 주로 일어난다. `Number(value)`로도 형 변환을 할 수 있다.



**숫자형으로의 변환은 아래 규칙을 따른다.**

| 전달받은 값    | 형 변환 후                                                   |
| :------------- | :----------------------------------------------------------- |
| `undefined`    | `NaN`                                                        |
| `null`         | `0`                                                          |
| `true / false` | `1 / 0`                                                      |
| `string`       | 전달받은 문자열을 “그대로” 읽되, 처음과 끝의 공백을 무시한다. 문자열이 비어있다면 `0`이 되고, 오류 발생 시 `NaN`이 된다. |

**`불린형으로 변환`** 은 논리 연산 시 발생한다. `Boolean(value)`으로도 변환할 수 있다.



**불린형으로의 형 변환은 다음 규칙을 따른다.**

| 전달받은 값                           | 형 변환 후 |
| :------------------------------------ | :--------- |
| `0`, `null`, `undefined`, `NaN`, `""` | `false`    |
| 그 외의 값                            | `true`     |



**형 변환 시 적용되는 규칙 대부분은 이해하고 기억하기 쉬운 편에 속한다. 다만 아래는 예외적인 경우이기 때문에 실수를 방지하기 위해 따로 기억해 두자.**

1.숫자형으로 변환 시 `undefined`는 `0`이 아니라 `NaN`이 된다.

2.문자열 `"0"`과 `" "`같은 공백은 불린형으로 변환 시 `true`가 된다.



#### 2.8 기본 연산자와 수학

**operand**(피연산자): 연산자가 연산을 수행하는 대상, 예를 들어 `5 * 2`에는 왼쪽 피연산자 `5`와 오른쪽 피연산자 `2`, 총 두 개의 피연산자가 있다. '피연산자’는 'argument(인수)'라는 용어로 불리기도 한다.

**unary**(단항)연산자: 피연산자를 하나만 받는 연산자, 피연산자의 부호를 뒤집는 단항 마이너스 연산자 `-`는 단항 연산자의 대표적인 예이다.

```javascript
let x = 1;

x = -x;
alert( x ); // -1, 단항 마이너스 연산자는 부호를 뒤집는다.
```

**binary**(이항)연산자: 두 개의 피연산자를 받는 연산자

```javascript
let x = 1, y = 3;
alert( y - x ); // 2, 이항 마이너스 연산자는 뺄셈을 해준다.
```

**위와 같이 부호를 반전해주는 단항 마이너스 연산자와 뺄셈에 쓰이는 이항 마이너스 연산자(뺄셈 연산자)는 기호는 같지만 수행하는 연산이 다르다. 두 연산을 구분하는 기준은 피연산자의 갯수이다.**

> **수학**
>
> 자바스크립트에서 지원하는 수학 연산자는 다음과 같다.
>
> > 덧셈 연산자 `+`, 뺄셈 연산자 `-`, 곱셈 연산자 `*`, 나눗셈 연산자 `/`, 나머지 연산자 `%`, 거듭제곱 연산자 `**`

**remainder operator**(나머지 연산자): `%` 기호로 나타내지만, 비율을 나타내는 퍼센트와 관련이 없다.

```javascript
나머지 연산자를 사용한 표현식 a % b는 a를 b로 나눈 후 그 remainder(나머지)를 정수로 반환해 준다.

alert( 5 % 2 ); // 5를 2로 나눈 후의 나머지인 1을 출력
alert( 8 % 3 ); // 8을 3으로 나눈 후의 나머지인 2를 출력
```

**exponentiation operator**(거듭제곱 연산자): `**` 기호를 사용하며, `a ** b`를 평가하면 `a`를 `b`번 곱한 값이 반환된다.

```javascript
alert( 2 ** 2 ); // 4  (2 * 2)
alert( 2 ** 3 ); // 8  (2 * 2 * 2)
alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2)

거듭제곱 연산자는 정수가 아닌 숫자에 대해서도 동작한다. 1/2을 사용하면 제곱근을 구할 수 있죠.

alert( 4 ** (1/2) ); // 2 (1/2 거듭제곱은 제곱근)
alert( 8 ** (1/3) ); // 2 (1/3 거듭제곱은 세제곱근)
```

**이상 연산자 '+'와 문자열 연결**

덧셈 연산자 `+`는 대개 숫자를 더한 결과를 반환하는데, 이항 연산자 `+`의 피연산자로 `문자열`이 전달되면 덧셈 연산자는 `덧셈이 아닌 문자열을 병합(연결)한다.`

**따라서 이항 연산자 `+`를 사용할 때는 피연산자 중 하나가 문자열이면 다른 하나도 문자열로 변환된다는 점에 반드시 주의해야 한다!**

``` javascript
let s = "my" + "string";
alert(s); // mystring

첫 번째 피연산자가 문자열인지, 두 번째 피연산자가 문자열인지는 중요하지 않습니다. 피연산자 중 어느 하나가 문자열이면 다른 하나도 문자열로 변환된다.
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"

alert(2 + 2 + '1' ); // '221'이 아니라 '41'이 출력된다.
```

연산은 왼쪽에서 오른쪽으로 순차적으로 진행되기 때문에 이런 결과가 나왔다. 두 개의 숫자 뒤에 문자열이 오는 경우, 숫자가 먼저 더해지고, 그 후 더해진 숫자와 문자열과의 병합이 일어난다. 이처럼 이항 덧셈 연산자 `+`는 문자열 연결과 변환이라는 특별한 기능을 제공한다. **`다른 산술 연산자가 오직 숫자형의 피연산자`만 다루고, `피연산자가 숫자형이 아닌 경우에 그 형을 숫자형으로 바꾸는 것`과는 대조적이다.**

아래는 뺄셈 `-`과 나눗셈 `/` 연산자가 어떻게 문자형 피연산자를 다루는지를 보여준다.

```javascript
alert( 6 - '2' ); // 4, '2'를 숫자로 바꾼 후 연산이 진행된다.
alert( '6' / '2' ); // 3, 두 피연산자가 숫자로 바뀐 후 연산이 진행된다.
```

**단항 연산자 +와 숫자형으로의 변환**

숫자에 단항 덧셈 연산자를 붙이면 이 연산자는 아무런 동작도 하지 않지만 피연산자가 `숫자가 아닌 경우엔 숫자형으로의 변환이 일어납니디.`

```javascript
// 숫자에는 아무런 영향을 미치지 않는다.
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// 숫자형이 아닌 피연산자는 숫자형으로 변화한다.
alert( +true ); // 1
alert( +"" );   // 0
```

**단항 덧셈 연산자는 위 예제와 같이 짧은 문법으로도 `Number(...)`와 동일한 일을 할 수 있게 해준다.**



#### 연산자 우선순위

| 순위 | 연산자 이름 | 기호 |
| :--- | :---------- | :--: |
| …    | …           |  …   |
| 17   | 단항 덧셈   | `+`  |
| 17   | 단항 부정   | `-`  |
| 16   | 지수        | `**` |
| 15   | 곱셈        | `*`  |
| 15   | 나눗셈      | `/`  |
| 13   | 덧셈        | `+`  |
| 13   | 뺄셈        | `-`  |
| …    | …           |  …   |
| 3    | 할당        | `=`  |
| …    | …           |  …   |

## [할당 연산자](https://ko.javascript.info/operators#ref-152)

### [값을 반환하는 할당 연산자](https://ko.javascript.info/operators#ref-153)

### [할당 연산자 체이닝](https://ko.javascript.info/operators#ref-154)

## [복합 할당 연산자](https://ko.javascript.info/operators#ref-155)

## [증가·감소 연산자](https://ko.javascript.info/operators#ref-156)

- **증가(increment) 연산자** `++`는 변수를 1 증가

  ```javascript
  let counter = 2;
  counter++;      // counter = counter + 1과 동일하게 동작하지만 식은 더 짧다.
  alert( counter ); // 3
  ```

- **감소(decrement) 연산자** `--`는 변수를 1 감소

  ```javascript
  let counter = 2;
  counter--;      // counter = counter - 1과 동일하게 동작하지만 식은 더 짧다.
  alert( counter ); // 1
  ```

**중요:**

증가/감소 연산자는 `변수에만` 쓸 수 있습니다. `5++`와 같이 값에 사용하려고 하면 에러가 발생한다.

`++`와`--` 연산자는 변수 앞이나 뒤에 올 수 있다.

- `counter++`와 같이 피연산자 뒤에 올 때는, 'postfix form(후위형)'이라고 부른다.
- `++counter`와 같이 피연산자 앞에 올 때는, 'prefix form(전위형)'이라고 부른다.

후위형과 전위형은 피연산자인 `counter`를 `1`만큼 증가시켜 준다는 점에서 동일한 일을 한다.

두 형의 차이는 `++/--`의 반환 값을 사용할 때 드러난다.

모든 연산자는 값을 반환한다. 증가/감소 연산자도 마찬가지인데, 전위형은 증가/감소 후의 새로운 값을 반환하는 반면, 후위형은 증가/감소 전의 기존 값을 반환한다.

```javascript
let counter = 1;
let a = ++counter; // (*)

alert(a); // 2
```

`(*)`로 표시한 줄의 *전위형* `++counter`는 `counter`를 증가시키고 새로운 값 `2`를 반환한다. 따라서 `alert`는 `2`를 표시된다.

```javascript
let counter = 1;
let a = counter++; // (*) ++counter를 counter++로 바꿈

alert(a); // 1
```

`(*)`로 표시한 줄의 *후위형* `counter++`는 `counter`를 증가시키긴 하지만, 증가 전의 *기존* 값을 반환한다. 따라서 `alert`는 `1`을 표시한다.

- **반환 값을 사용하지 않는 경우라면, 전위형과 후위형엔 차이가 없다.**

  ```javascript
  let counter = 0;
  counter++;
  ++counter;
  alert( counter ); // 2, 위 두 라인은 동일한 연산을 수행합니다.
  ```

- > 값을 증가시키고 난 후, 증가한 값을 바로 사용하려면 전위형 증가 연산자를 사용하면 된다.

  ```javascript
  let counter = 0;
  alert( ++counter ); // 1
  ```

- > 값을 증가시키지만, 증가 전의 기존값을 사용하려면 후위형 증가 연산자를 사용하면 된다.

  ```javascript
  let counter = 0;
  alert( counter++ ); // 0
  ```

**다른 연산자 사이의 증가/감소 연산자**

`++/--` 연산자를 표현식 중간에 사용하는 것도 가능합니다. 이때, 증가/감소 연산자의 우선순위는 다른 대부분의 산술 연산자보다 높기 때문에, 평가가 먼저 이뤄진다.

```javascript
let counter = 1;
alert( 2 * ++counter ); // 4
```

```javascript
let counter = 1;
alert( 2 * counter++ ); // counter++는 '기존'값을 반환하기 때문에 2가 출력된다.
```

**이렇게 코드를 작성하는 게 기술적으로 문제가 있는 것은 아니지만, 한 줄에서 여러 가지 일을 동시에 하고 있기 때문에 코드의 가독성이 떨어진다.**

코드를 읽을 때 눈을 ‘수직으로’ 빠르게 움직이다 보면 `counter++`와 같은 것을 놓치기 쉬워 변수가 증가했다는 것을 놓칠 수 있죠.

'코드 한 줄엔, 특정 동작 하나’에 관련된 내용만 작성하는 게 좋다.

```javascript
let counter = 1;
alert( 2 * counter );
counter++;
```

## [비트 연산자](https://ko.javascript.info/operators#ref-157)

bitwise operator(비트 연산자): 인수를 32비트 정수로 변환하여 이진 연산을 수행하는 연산자

> - 비트 AND ( `&` )
> - 비트 OR ( `|` )
> - 비트 XOR ( `^` )
> - 비트 NOT ( `~` )
> - 왼쪽 시프트(LEFT SHIFT) ( `<<` )
> - 오른쪽 시프트(RIGHT SHIFT) ( `>>` )
> - 부호 없는 오른쪽 시프트(ZERO-FILL RIGHT SHIFT) ( `>>>` )

비트 연산자는 저수준(2진 표현)에서 숫자를 다뤄야 할 때 쓰이므로 흔하게 쓰이진 않는다. 웹 개발 시엔 이런 일이 자주 일어나지 않기 때문에 비트 연산자를 만날 일은 거의 없다. 하지만, 암호를 다뤄야 할 땐 비트 연산자가 유용하기 때문에 때가 되면 MDN의 [비트 연산자](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators) 문서를 보시는 걸 추천한다.

## [쉼표 연산자](https://ko.javascript.info/operators#ref-158)

comma operator(쉼표 연산자): `,`는 좀처럼 보기 힘들고, 특이한 연산자 중 하나다. 코드를 짧게 쓰려는 의도로 가끔 사용되는데 이런 코드를 만났을 때 어떤 연산 결과가 도출되는지 알아야 한다.

쉼표 연산자 `,`는 여러 표현식을 코드 한 줄에서 평가할 수 있게 해준다. 이때 표현식 각각이 모두 평가되지만, 마지막 표현식의 평가 결과만 반환되는 점에 유의해야한다.

```javascript
let a = (1 + 2, 3 + 4);

alert( a ); // 7 (3 + 4의 결과)
```

위 예시에서 첫 번째 표현식 `1 + 2`은 평가가 되지만 그 결과는 버려진다. `3 + 4`만 평가되어 `a`에 할당된다.

**쉼표의 우선순위는 매우 낮다.**

그렇기에, 쉼표 연산자의 연산자 우선순위는 매우 낮습니다. 할당 연산자 `=` 보다 더 낮다. 따라서 위 예시에선 괄호가 중요한 역할을 한다.

괄호가 없으면 `a = 1 + 2, 3 + 4`에서 `+`가 먼저 수행되어 `a = 3, 7`이 된다. 할당 연산자 `=`는 쉼표 연산자보다 우선순위가 높기 때문에 `a = 3`이 먼저 실행되고, 나머지(`7`)는 무시된다. `(a = 1 + 2), 3 + 4`를 연산한 것처럼 결과가 발생한다.

> **❗**이렇게 마지막 표현식을 제외한 모든 것을 버리는 연산자는 어디서 사용되는 걸까?
>
>    여러 동작을 하나의 줄에서 처리하려는 복잡한 구조에서 이를 사용한다.
>
> ```javascript
> // 한 줄에서 세 개의 연산이 수행됨
> for (a = 1, b = 3, c = a * b; a < 10; a++) {
>  ...
> }
> ```

**쉼표 연산자를 사용한 트릭은 여러 자바스크립트 프레임워크에서 볼 수 있다. 이 연산자의 사용 빈도가 높지 않지만, 언급하고 넘어가는 이유다. 쉼표 연산자는 코드 가독성에 도움이 되지 않기 때문에, 곰곰이 생각해 본 후, 진짜 필요한 경우에만 사용하자.**

>  **quiz**
>
> 아래 표현식들의 결과를 예측해 보세요.
>
> ```javascript
> "" + 1 + 0
> "" - 1 + 0
> true + false
> 6 / "3"
> "2" * "3"
> 4 + 5 + "px"
> "$" + 4 + 5
> "4" - 2
> "4px" - 2
> 7 / 0
> "  -9  " + 5
> "  -9  " - 5
> null + 1
> undefined + 1
> " \t \n" - 2
> ```

> 해답
>
> ```javascript
> "" + 1 + 0 = "10" // (1)
> "" - 1 + 0 = -1 // (2)
> true + false = 1
> 6 / "3" = 2
> "2" * "3" = 6
> 4 + 5 + "px" = "9px"
> "$" + 4 + 5 = "$45"
> "4" - 2 = 2
> "4px" - 2 = NaN
> 7 / 0 = Infinity
> "  -9  " + 5 = "  -9  5" // (3)
> "  -9  " - 5 = -14 // (4)
> null + 1 = 1 // (5)
> undefined + 1 = NaN // (6)
> " \t \n" - 2 = -2 // (7)
> ```
>
> 1. 피 연산자 중 하나가 문자열인 `"" + 1`에서 `1`은 문자형으로 변환된다. 따라서 공백과 문자열 1을 더한, `"" + 1 = "1"`과 같은 효과를 내는데 그다음 연산 `"1" + 0`에도 같은 규칙이 적용된다.
> 2. 뺄셈 연산자 `-`는 기타 수학 연산자처럼 숫자형만을 인수로 받는다. 빈 문자열 `""`는 숫자 `0`으로 변환되기 때문에 결과는 `-1`이 된다.
> 3. 피 연산자 중 하나가 문자열이므로 숫자 5가 문자열로 변환된다.
> 4. 뺄셈 연산자는 인수를 숫자형으로 변화시키므로 `" -9 "`는 숫자 `-9`로 변합니다. 앞, 뒤 공백은 제거 된다.
> 5. 숫자형으로 변환 시 `null`은 `0`이 된다.
> 6. `undefined`는 숫자형으로 변환시 `NaN`이 된다.
> 7. 문자열이 숫자형으로 변할 땐 문자열 앞뒤의 공백이 삭제된다. 뺄셈 연산자 앞의 피연산자는 공백을 만드는 문자 `\t`와 `\n`, 그 사이의 “일반적인” 공백으로 구성된다. 따라서 `" \t \n"`는 숫자형으로 변환 시 길이가 `0`인 문자열로 취급되어 숫자 `0`이 된다.

**❗**숫자형으로 변환 시 `null`은 `0`이 되고, `undefined`는 숫자형으로 변환시 `NaN`이 된다.

> **quiz**
>
> 아래 코드는 사용자에게 숫자 2개를 입력받은 다음 그 합을 보여준다.
>
> 그런데 의도한 대로 예시가 동작하지 않는다. 프롬프트 창에 세팅한 기본값을 수정하지 않은 경우 덧셈의 결과는 `12`가 된다.
>
> 왜 그럴까? 예시가 제대로 동작하도록 코드를 수정해 보자. 결과는 `3`이 되어야 한다.
>
> ```javascript
> let a = prompt("덧셈할 첫 번째 숫자를 입력해주세요.", 1);
> let b = prompt("덧셈할 두 번째 숫자를 입력해주세요.", 2);
> 
> alert(a + b); // 12
> ```

> 해답
>
> 의도한 대로 덧셈이 되지 않는 이유는 prompt 함수가 사용자 입력을 문자열로 반환하기 때문이다.
>
> 그래서 프롬프트 창에서 입력한 변수들은 각각 문자열인 `"1"`과 `"2"`가 된다.
>
> ```javascript
> let a = "1"; // prompt("덧셈할 첫 번째 숫자를 입력해주세요.", 1);
> let b = "2"; // prompt("덧셈할 두 번째 숫자를 입력해주세요.", 2);
> 
> alert(a + b); // 12
> ```
>
> 예시가 제대로 동작하게 하려면 덧셈 연산 `+`가 수행되기 전에 문자열을 숫자로 변환해야 한다. 이때 `Number()`를 사용하거나 변수 앞에 `+`를 붙여줄 수 있다.
>
> 아래 코드에선 `prompt` 함수 바로 앞에서 문자열을 숫자로 변환했다.
>
> ```javascript
> let a = +prompt("덧셈할 첫 번째 숫자를 입력해주세요.", 1);
> let b = +prompt("덧셈할 두 번째 숫자를 입력해주세요.", 2);
> 
> alert(a + b); // 3
> ```
>
> 아래 코드에선 `alert` 함수 안에서 문자열을 숫자로 변환해 보았다.
>
> ```javascript
> let a = prompt("덧셈할 첫 번째 숫자를 입력해주세요.", 1);
> let b = prompt("덧셈할 두 번째 숫자를 입력해주세요.", 2);
> 
> alert(+a + +b); // 3
> ```
>
> 코드 한 줄 안에서 단항, 이항 `+` 연산자를 한꺼번에 쓰니 조금 웃겨 보인다.



#### 2.9 비교연산자

> **보다 큼·작음**: `a > b`, `a < b`.
>
> **보다 크거나·작거나 같음**: `a >= b`, `a <= b`.
>
> **같음(동등)**: `a == b`. 등호 `=`가 두 개 연달아 오는 것에 유의하자. `a = b`와 같이 등호가 하나일 때는 할당을 의미한다.
>
> **같지 않음(부등)**: 같지 않음을 나타내는 수학 기호 `≠`는 자바스크립트에선 `a != b`로 나타낸다. 할당연산자 `=` 앞에 느낌표 `!`를 붙여서 표시한다.

## [불린형 반환](https://ko.javascript.info/comparison#ref-671)

> 다른 연산자와 마찬가지로 비교 연산자 역시 값을 반환하며, 반환 값은 불린형입니다.
>
> `true`가 반환되면, ‘긍정’, ‘참’, '사실’을 의미한다.
>
> `false`가 반환되면, ‘부정’, ‘거짓’, '사실이 아님’을 의미한다.

```javascript
alert( 2 > 1 );  // true
alert( 2 == 1 ); // false
alert( 2 != 1 ); // true
```

반환된 불린값은 다른 여타 값처럼 변수에 할당 할 수 있다.

```javascript
let result = 5 > 4; // 비교 결과를 변수에 할당
alert( result ); // true
```

## [문자열 비교](https://ko.javascript.info/comparison#ref-672)

> 자바스크립트는 `'사전’순으로 문자열을 비교한다.` '사전편집(lexicographical)'순 이라고 불리기도 하는 이 기준을 적용하면 사전 뒤쪽의 문자열은 사전 앞쪽의 문자열보다 크다고 판단된다.

실제 단어를 사전에 실을 때 단어를 구성하는 문자 하나하나를 비교하여 등재 순서를 정하는 것과 같이 자바스크립트도 문자열을 구성하는 문자 하나하나를 비교해가며 문자열을 비교한다.

```javascript
alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
```

> 문자열 비교 시 적용되는 알고리즘은 다음과 같다.
>
> 1. 두 문자열의 첫 글자를 비교한다.
> 2. 첫 번째 문자열의 첫 글자가 다른 문자열의 첫 글자보다 크면(작으면), 첫 번째 문자열이 두 번째 문자열보다 크다고(작다고) 결론 내고 비교를 종료한다.
> 3. 두 문자열의 첫 글자가 같으면 두 번째 글자를 같은 방식으로 비교한다.
> 4. 글자 간 비교가 끝날 때까지 이 과정을 반복한다.
> 5. 비교가 종료되었고 문자열의 길이도 같다면 두 문자열은 동일하다고 결론낸다. 비교가 종료되었지만 두 문자열의 길이가 다르면 길이가 긴 문자열이 더 크다고 결론 낸다.
>
> 예시의 `'Z' > 'A'`는 위 알고리즘의 첫 번째 단계에서 비교 결과가 도출된다. 반면, 문자열 `"Glow"`와 `"Glee"`는 복수의 문자로 이루어진 문자열이기 때문에, 아래와 같은 순서로 문자열 비교가 이뤄진다.
>
> 1. `G`는 `G`와 같다.
> 2. `l`은 `l`과 같다.
> 3. `o`는 `e`보다 크기 때문에 여기서 비교가 종료되고, `o`가 있는 첫 번째 문자열 `"Glow"`가 더 크다는 결론이 도출된다.

**정확히는 사전순이 아니라 `유니코드 순`이다.**

자바스크립트의 문자열 비교 알고리즘은 사전이나 전화번호부에서 사용되는 정렬 알고리즘과 아주 유사하지만, 완전히 같진 않는데,차이점 중 하나는 자바스크립트는 대·소문자를 따진다는 것이다. 대문자 `"A"`와 소문자 `"a"`를 비교했을 때 소문자 `"a"`가 더 크다. 자바스크립트 내부에서 사용되는 인코딩 표인 유니코드에선 소문자가 대문자보다 더 큰 인덱스를 갖기 때문이다.

## [다른 형을 가진 값 간의 비교](https://ko.javascript.info/comparison#ref-673)

비교하려는 값의 자료형이 다르면 자바스크립트는 이 값들을 `숫자형`으로 바꾼다.

```javascript
alert( '2' > 1 ); // true, 문자열 '2'가 숫자 2로 변환된 후 비교가 진행된다.
alert( '01' == 1 ); // true, 문자열 '01'이 숫자 1로 변환된 후 비교가 진행된다.
```

불린값의 경우 `true`는 `1`, `false`는 `0`으로 변환된 후 비교가 이뤄진다.

```javascript
alert( true == 1 ); // true
alert( false == 0 ); // true
```

**흥미로운 상황**

>  같이 일어나지 않을 법한 두 상황이 동시에 일어나는 경우도 있다.
>
> 1. 동등 비교(`==`) 시 true를 반환함
>
> 2. 논리 평가 시 값 하나는 `true`, 다른 값 하나는 `false`를 반환함
>
> ```javascript
> let a = 0;
> alert( Boolean(a) ); // false
> 
> let b = "0";
> alert( Boolean(b) ); // true
> 
> alert(a == b); // true!
> ```
>
> 두 값을 비교했을 때 참이 반환되는데, 값을 논리 평가한 후 비교하면 하나는 거짓이 반환된다는 점이 당황스럽다. 하지만, 자바스크립트의 관점에선 이런 결과가 아주 자연스러운데, 동등 비교 연산자 `==`는 (예시에서 문자열 `"0"`을 숫자 `0`으로 변환시킨 것처럼) 피연산자를 숫자형으로 바꾸지만, 'Boolean’을 사용한 명시적 변환에는 다른 규칙이 사용되기 때문이다.

## [일치 연산자](https://ko.javascript.info/comparison#ref-674)

equality operator(동등연산자) `==`은 `0`과 `false`를 구별하지 못한다.

```javascript
alert( 0 == false ); // true
```

피연산자가 빈 문자열일 때도 같은 문제가 발생한다.

```javascript
alert( '' == false ); // true
```

이런 문제는 동등 연산자 `==`가 형이 다른 피연산자를 비교할 때 피연산자를 숫자형으로 바꾸기 때문에 발생한다. 빈 문자열과 `false`는 숫자형으로 변환하면 0이 된다.

그렇다면 `0`과 `false`는 어떻게 구별할 수 있을까?

**일치 연산자(strict equality operator) `===`를 사용하면 형 변환 없이 값을 비교할 수 있다.**

일치 연산자는 `엄격한(strict) 동등 연산자`다. **`자료형의 동등 여부까지 검사`**하기 때문에, 피연산자 `a`와 `b`의 형이 다를 경우 `a === b`는 `false`를 즉시 반환한다.

```javascript
alert( 0 === false ); // false, 피연산자의 형이 다르기 때문이다.
```

일치 연산자 `===`가 동등 연산자 `==`의 엄격한 형태인 것처럼 “불일치” 연산자 `!==`는 부등 연산자 `!=`의 엄격한 형태다.

일치 연산자는 동등 연산자보다 한 글자 더 길긴 하지만 비교 결과가 명확하기 때문에 에러가 발생할 확률을 줄여준다.

## [null이나 undefined와 비교하기](https://ko.javascript.info/comparison#ref-675)

`null`이나 `undefined`를 다른 값과 비교할 땐 예상치 않은 일들이 발생한다.

> > **일치 연산자 `===`를 사용하여 `null`과 `undefined`를 비교**
> >
> > 두 값의 자료형이 다르기 때문에 일치 비교 시 `거짓이 반환`된다.
> >
> > `alert( null === undefined ); // false`
>
> > **동등 연산자 `==`를 사용하여 `null`과 `undefined`를 비교**
> >
> > 동등 연산자를 사용해 `null`과 `undefined`를 비교하면 특별한 규칙이 적용돼 `true`가 반환된다. 동등 연산자는 `null`과 `undefined`를 '각별한 커플’처럼 취급한다. 두 값은 자기들끼리는 잘 어울리지만 다른 값들과는 잘 어울리지 못한다.
> >
> > `alert( null == undefined ); // true`
>
> > **산술 연산자나 기타 비교 연산자 `< > <= >=`를 사용하여 `null`과 `undefined`를 비교**
> >
> > `null`과 `undefined`는 숫자형으로 변환됩니다. `null`은 `0`, `undefined`는 `NaN`으로 변합니다.

### [null vs 0](https://ko.javascript.info/comparison#ref-676)

`null`과 0을 비교해보면

```javascript
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
```

위의 비교 결과는 논리에 맞지 않는다. (3)에서 `null`은 `0`보다 크거나 같다고 했기 때문에, (1)이나 (2) 중 하나는 참이어야 하는데 둘 다 거짓을 반환하고 있다.

**이는 동등 연산자 `==`와 기타 비교 연산자 `> < >= <=`의 동작 방식이 다르기 때문이다. (1)에서 `null > 0`이 거짓을, (3)에서 `null >= 0`이 참을 반환하는 이유는 (기타 비교 연산자의 동작 원리에 따라) `null`이 숫자형으로 변환돼 `0`이 되기 때문이다.**

**그런데 동등 연산자 `==`는 피연산자가 `undefined`나 `null`일 때 형 변환을 하지 않는다. `undefined`와 `null`을 비교하는 경우에만 `true`를 반환하고, 그 이외의 경우(`null`이나 `undefined`를 다른 값과 비교할 때)는 무조건 `false`를 반환한다. 이런 이유 때문에 (2)는 거짓을 반환한다.**

### [비교가 불가능한 undefined](https://ko.javascript.info/comparison#ref-677)

**`undefined`를 다른 값과 비교해서는 안 됩니다.**

```javascript
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```

위 예시의 결과를 보면 `undefined`는 항상 `false`를 반환하고 있다.

이런 결과는 아래와 같은 이유 때문에 발생한다.

- `(1)`과`(2)`에선 `undefined`가 `NaN`으로 변환되는데(숫자형으로의 변환), `NaN`이 피연산자인 경우 비교 연산자는 항상 `false`를 반환한다.
- `undefined`는 `null`이나 `undefined`와 같고, 그 이외의 값과는 같지 않기 때문에 `(3)`은 `false`를 반환한다.

### [함정 피하기](https://ko.javascript.info/comparison#ref-678)

- 일치 연산자 `===`를 제외한 비교 연산자의 피연산자에 `undefined`나 `null`이 오지 않도록 특별히 주의하자.
- 또한, `undefined`나 `null`이 될 가능성이 있는 변수가 `>= > < <=`의 피연산자가 되지 않도록 주의하자. 
- 만약 변수가 `undefined`나 `null`이 될 가능성이 있다고 판단되면, 이를 따로 처리하는 코드를 추가해서 사용하자.

## [요약](https://ko.javascript.info/comparison#ref-679)

- 비교 연산자는 불린값을 반환한다.
- 문자열은 문자 단위로 비교되는데, 이때 비교 기준은 '사전’순입니다.
- 서로 다른 타입의 값을 비교할 땐 숫자형으로 형 변환이 이뤄지고 난 후 비교가 진행된다(일치 연산자는 제외).
- `null`과 `undefined`는 동등 비교(`==`) 시 서로 같지만 다른 값과는 같지 않다.
- `null`이나 `undefined`가 될 확률이 있는 변수가 `>` 또는 `<`의 피연산자로 올 때는 주의하자. `null/undefined` 여부를 확인하는 코드를 따로 추가하는 습관을 들이길 권장한다.

> **quiz**
>
> 아래 표현식들의 결과를 예측해보세요.
>
> ```javascript
> 5 > 4
> "apple" > "pineapple"
> "2" > "12"
> undefined == null
> undefined === null
> null == "\n0\n"
> null === +"\n0\n"
> ```

> 정답
>
> ```javascript
> 5 > 4 → true
> "apple" > "pineapple" → false
> "2" > "12" → true
> undefined == null → true
> undefined === null → false
> null == "\n0\n" → false
> null === +"\n0\n" → false
> ```
>
> 해설:
>
> 1. 명백히 true다.
> 2. 문자열의 비교는 사전순서가 기준이므로 false입니다. `"a"`는 `"p"`보다 작다.
> 3. 두 피연산자는 문자열이므로, 사전순으로 비교가 이뤄지며, 왼쪽 피연산자의 첫 번째 글자 `"2"`는 오른쪽 피연산자의 첫 번째 글자 `"1"`보다 크다.
> 4. `null`과 `undefined`는 같다.
> 5. 일치 연산자는 형도 체크한다. 형이 다르면 false가 반환된다.
> 6. `null`은 오직 `undefined`와 같다.
> 7. 형이 다르므로 false가 반환된다.



#### 2.10 if와 '?'를 사용한 조건 처리

## ['if’문](https://ko.javascript.info/ifelse#ref-225)

`if(...)`문은 괄호 안에 들어가는 조건을 평가하는데, 그 결과가 `true`이면 코드 블록이 실행된다.

```javascript
let year = prompt('ECMAScript-2015 명세는 몇 년도에 출판되었을까요?', '');

if (year == 2015) alert( '정답입니다!' );
```

위 예시에선 조건(`year == 2015`)이 간단한 경우만 다뤘는데, 조건문은 더 복잡할 수도 있다.

조건이 `true`일 때 복수의 문을 실행하고 싶다면 중괄호로 코드 블록을 감싸야 한다.

```javascript
if (year == 2015) {
  alert( "정답입니다!" );
  alert( "아주 똑똑하시네요!" );
}
```

`if`문을 쓸 때는 조건이 참일 경우 실행되는 구문이 단 한 줄이더라도 중괄호 `{}`를 사용해 코드를 블록으로 감싸는 것을 권장하는데 이렇게 하면 코드 가독성이 증가하기 때문이다.

## [불린형으로의 변환](https://ko.javascript.info/ifelse#ref-226)

`if (…)` 문은 괄호 안의 표현식을 평가하고 그 결과를 불린값으로 변환한다.

[형 변환](https://ko.javascript.info/type-conversions) 챕터에서 배운 형 변환 규칙을 잠시 상기보면,

- 숫자 `0`, 빈 문자열`""`, `null`, `undefined`, `NaN`은 불린형으로 변환 시 모두 `false`가 된다. 이런 값들은 ‘falsy(거짓 같은)’ 값이라고 부른다.
- 이 외의 값은 불린형으로 변환시 `true`가 되므로 ‘truthy(참 같은)’ 값이라고 부른다.

이 규칙에 따르면 아래 예시의 코드 블록은 절대 실행되지 않는다.

```javascript
if (0) { // 0은 falsy입니다.
  ...
}
```

아래 예시의 코드 블록은 항상 실행된다.

```javascript
if (1) { // 1은 truthy입니다.
  ...
}
```

아래와 같이 평가를 통해 확정된 불린값을 `if`문에 전달할 수도 있다.

```javascript
let cond = (year == 2015); // 동등 비교를 통해 true/false 여부를 결정합니다.

if (cond) {
  ...
}
```

## ['else’절](https://ko.javascript.info/ifelse#ref-227)

`if`문엔 `else` 절을 붙일 수 있다. `else` 뒤에 이어지는 코드 블록은 조건이 거짓일 때 실행된다.

```javascript
let year = prompt('ECMAScript-2015 명세는 몇 년도에 출판되었을까요?', '');

if (year == 2015) {
  alert( '정답입니다!' );
} else {
  alert( '오답입니다!' ); // 2015 이외의 값을 입력한 경우
}
```

## ['else if’로 복수 조건 처리하기](https://ko.javascript.info/ifelse#ref-228)

```javascript
let year = prompt('ECMAScript-2015 명세는 몇 년도에 출판되었을까요?', '');

if (year < 2015) {
  alert( '숫자를 좀 더 올려보세요.' );
} else if (year > 2015) {
  alert( '숫자를 좀 더 내려보세요.' );
} else {
  alert( '정답입니다!' );
}
```

위 예시에서, 자바스크립트는 조건 `year < 2015`를 먼저 확인하고, 이 조건이 거짓이라면 다음 조건 `year > 2015`를 확인한다. 이 조건 또한 거짓이라면 `else` 절 내의 `alert`를 실행한다.

`else if` 블록을 더 많이 붙이는 것도 가능하다. 마지막에 붙는 `else`는 필수가 아닌 선택 사항이다.

## [조건부 연산자 ‘?’](https://ko.javascript.info/ifelse#ref-229)

조건에 따라 다른 값을 변수에 할당해줘야 할 때가 있다.

```javascript
let accessAllowed;
let age = prompt('나이를 입력해 주세요.', '');

if (age > 18) {
  accessAllowed = true;
} else {
  accessAllowed = false;
}

alert(accessAllowed);
```

'물음표(question mark) 연산자’라고도 불리는 '조건부(conditional) 연산자’를 사용하면 위 예시를 더 짧고 간결하게 변형할 수 있다.

조건부 연산자는 물음표`?`로 표시한다. 피연산자가 세 개이기 때문에 조건부 연산자를 `'삼항(ternary) 연산자’`라고 부르는 사람도 있다. 참고로, 자바스크립트에서 피연산자가 3개나 받는 연산자는 조건부 연산자가 유일하다.

```javascript
let result = condition ? value1 : value2;
```

평가 대상인 `condition`이 truthy라면 `value1`이, 그렇지 않으면 `value2`가 반환된다.

```javascript
let accessAllowed = (age > 18) ? true : false;
```

`age > 18` 주위의 괄호는 생략 가능하다. 물음표 연산자는 우선순위가 낮으므로 비교 연산자 `>`가 실행되고 난 뒤에 실행된다.

아래 예시는 위 예시와 동일하게 동작한다.

```javascript
// 연산자 우선순위 규칙에 따라, 비교 연산 'age > 18'이 먼저 실행됩니다.
// (조건문을 괄호로 감쌀 필요가 없습니다.)
let accessAllowed = age > 18 ? true : false;
```

괄호가 있으나 없으나 차이는 없지만, 코드의 가독성 향상을 위해 괄호를 사용할 것을 권장한다.

비교 연산자 자체가 `true`나 `false`를 반환하기 때문에 위 예시에서 물음표 연산자를 사용하지 않아도 된다.

```javascript
// 동일하게 동작함
let accessAllowed = age > 18;
```

## [다중 ‘?’](https://ko.javascript.info/ifelse#ref-230)

물음표 연산자`?`를 여러 개 연결하면 복수의 조건을 처리할 수 있다.

```javascript
let age = prompt('나이를 입력해주세요.', 18);

let message = (age < 3) ? '아기야 안녕?' :
  (age < 18) ? '안녕!' :
  (age < 100) ? '환영합니다!' :
  '나이가 아주 많으시거나, 나이가 아닌 값을 입력 하셨군요!';

alert( message );
```

> 1. 첫 번째 물음표에선 조건문 `age < 3`을 검사한다.
> 2. 그 결과가 참이면 `'아기야 안녕?'`를 반환한다. 그렇지 않다면 첫 번째 콜론 `":"`에 이어지는 조건문 `age < 18`을 검사한다.
> 3. 그 결과가 참이면 `'안녕!'`를 반환한다. 그렇지 않다면 다음 콜론 `":"`에 이어지는 조건문 `age < 100`을 검사한다.
> 4. 그 결과가 참이면 `'환영합니다!'`를 반환한다. 그렇지 않다면 마지막 콜론 `":"` 이후의 표현식인 `'나이가 아주 많으시거나, 나이가 아닌 값을 입력 하셨군요!'`를 반환한다.

`if..else`를 사용하면 위 예시를 아래와 같이 변형할 수 있다.

```javascript
if (age < 3) {
  message = '아기야 안녕?';
} else if (age < 18) {
  message = '안녕!';
} else if (age < 100) {
  message = '환영합니다!';
} else {
  message = '나이가 아주 많으시거나, 나이가 아닌 값을 입력 하셨군요!';
}
```

## [부적절한 ‘?’](https://ko.javascript.info/ifelse#ref-231)

물음표`?`를 `if` 대용으로 쓰는 경우가 종종 있다.

```javascript
let company = prompt('자바스크립트는 어떤 회사가 만들었을까요?', '');

(company == 'Netscape') ?
   alert('정답입니다!') : alert('오답입니다!');
```

조건 `company == 'Netscape'`의 검사 결과에 따라 `?` 뒤에 이어지는 첫 번째 혹은 두 번째 표현식이 실행되어 얼럿 창이 뜬다.

위 예시에선 평가 결과를 변수에 할당하지 않고, 결과에 따라 실행되는 표현식이 달라지도록 하였다.

그런데 **이런 식으로 물음표 연산자를 사용하는 것은 좋지 않다.**

개발자 입장에선 `if`문을 사용할 때 보다 코드 길이가 짧아진다는 점 때문에 물음표`?`를 `if` 대용으로 쓰는 게 매력적일 순 있다. 하지만 이렇게 코드를 작성하면 가독성이 떨어진다.

아래는 `if`를 사용해 변형한 코드다.

```javascript
let company = prompt('자바스크립트는 어떤 회사가 만들었을까요?', '');

if (company == 'Netscape') {
  alert('정답입니다!');
} else {
  alert('오답입니다!');
}
```

코드를 읽을 때 우리의 눈은 수직으로 움직이는데, 수평으로 길게 늘어진 코드보단 여러 줄로 나뉘어 작성된 코드 블록이 더 읽기 쉽다.

`물음표 연산자`?`는 조건에 따라 반환 값을 달리하려는 목적으로 만들어졌다.` 이런 목적에 부합하는 곳에 물음표를 사용하고, 여러 분기를 만들어 처리할 때는 `if`를 사용하자.



#### 2.11 논리 연산자

자바스크립트엔 세 종류의 논리 연산자 `||`(OR), `&&`(AND), `!`(NOT)이 있다.

‘OR’ 연산자는 두 개의 수직선 기호로 만들 수 있다.

```javascript
result = a || b;
```

전통적인 프로그래밍에서 OR 연산자는 불린값을 조작하는 데 쓰인다. 인수 중 하나라도 `true`이면 `true`를 반환하고, 그렇지 않으면 `false`를 반환한다.

자바스크립트의 OR 연산자는 다루긴 까다롭지만 강력한 기능을 제공한다. OR 연산자는 이항 연산자이므로 아래와 같이 네 가지 조합이 가능하다.

```javascript
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
```

피연산자가 모두 `false`인 경우를 제외하고 연산 결과는 항상 `true`다.

피연산자가 불린형이 아니면, 평가를 위해 불린형으로 변환된다. 예를 들어, 연산 과정에서 숫자 `1`은 `true`로, 숫자 `0`은 `false`로 바뀐다.

```javascript
if (1 || 0) { // if( true || false ) 와 동일하게 동작합니다.
  alert( 'truthy!' );
}
```

OR 연산자 `||`은 `if`문에서 자주 사용되며, 주어진 조건 중 *하나라도* `참`인지를 테스트하는 용도로 쓰인다.

```javascript
let hour = 9;

if (hour < 10 || hour > 18) {
  alert( '영업시간이 아닙니다.' );
}
```

`if`문 안에 여러 가지 조건을 넣을 수 있다.

```javascript
let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  alert( '영업시간이 아닙니다.' ); // 주말이기 때문임
}
```

## [첫 번째 truthy를 찾는 OR 연산자 ‘||’](https://ko.javascript.info/logical-operators#ref-143)

**`자바스크립트에서만 제공`하는 논리연산자 OR의 '추가’기능이 있다.** 추가 기능은 아래와 같은 알고리즘으로 동작한다.

OR 연산자와 피연산자가 여러 개인 경우:

```javascript
result = value1 || value2 || value3;
```

> 이때, OR `||`연산자는 다음 순서에 따라 연산을 수행한다.
>
> 1. 가장 왼쪽 피연산자부터 시작해 오른쪽으로 나아가며 피연산자를 평가한다.
>
> 2. 각 피연산자를 불린형으로 변환한다. 변환 후 그 값이 `true`이면 연산을 멈추고 해당 피연산자의 **변환 전** 원래 값을 반환한다.
>
> 3. 피연산자 모두를 평가한 경우(모든 피연산자가 `false`로 평가되는 경우)엔 마지막 피연산자를 반환한다.

여기서 핵심은 반환 값이 형 변환을 하지 않은 원래 값이다.

정리해 보면,

**OR `"||"` 연산자를 여러 개 체이닝(chaining) 하면 첫 번째 truthy를 반환한다. 피연산자에 truthy가 하나도 없다면 마지막 피연산자를 반환한다.**

```javascript
alert( 1 || 0 ); // 1 (1은 truthy임)

alert( null || 1 ); // 1 (1은 truthy임)
alert( null || 0 || 1 ); // 1 (1은 truthy임)

alert( undefined || null || 0 ); // 0 (모두 falsy이므로, 마지막 값을 반환함)
```



이런 OR 연산자의 추가 기능을 이용하면 여러 용도로 OR 연산자를 활용할 수 있다.

1. **변수 또는 표현식으로 구성된 목록에서 첫 번째 truthy 얻기**

   `firstName`, `lastName`, `nickName`이란 변수가 있는데 이 값들은 모두 옵션 값이라고 해보자.

   OR `||`을 사용하면 실제 값이 들어있는 변수를 찾고, 그 값을 보여줄 수 있다. 변수 모두에 값이 없는 경우엔 `익명`를 보여주자.

   ```javascript
   let firstName = "";
   let lastName = "";
   let nickName = "바이올렛";
   
   alert( firstName || lastName || nickName || "익명"); // 바이올렛
   ```

   모든 변수가 falsy이면 `"익명"`이 출력

   

2. **단락 평가**

   OR 연산자 `||`가 제공하는 또 다른 기능은 `'short circuit evaluation(단락 평가)'`다.

   위 설명과 같이 OR`||`은 왼쪽부터 시작해서 오른쪽으로 평가를 진행하는데, truthy를 만나면 나머지 값들은 건드리지 않은 채 평가를 멈춘다. 이런 프로세스를 '단락 평가’라고 한다.

   단락 평가의 동작 방식은 두 번째 피연산자가 변수 할당과 같은 `side effect(부수적인 효과)`를 가지는 표현식 일 때 명확히 볼 수 있다.

   아래 예시를 실행하면 두 번째 메시지만 출력된다.

   ```javascript
   true || alert("not printed");
   false || alert("printed");
   ```

   첫 번째 줄의 `||` 연산자는 `true`를 만나자마자 평가를 멈추기 때문에 `alert`가 실행되지 않는다.

   단락 평가는 연산자 왼쪽 조건이 falsy일 때만 명령어를 실행하고자 할 때 자주 쓰인다.

## [&& (AND)](https://ko.javascript.info/logical-operators#ref-144)

두 개의 앰퍼샌드를 연달아 쓰면 AND 연산자 `&&`를 만들 수 있다.

```javascript
result = a && b;
```

전통적인 프로그래밍에서 AND 연산자는 두 피연산자가 모두가 참일 때 `true`를 반환한다. 그 외의 경우는 `false`를 반환한다.

```javascript
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
```

아래는 `if`문과 AND 연산자를 함께 활용한 예제다.

```javascript
let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert( '현재 시각은 12시 30분입니다.' );
}
```

OR 연산자와 마찬가지로 AND 연산자의 피연산자도 타입에 제약이 없다.

```javascript
if (1 && 0) { // 피연산자가 숫자형이지만 논리형으로 바뀌어 true && false가 됩니다.
  alert( "if 문 안에 falsy가 들어가 있으므로 alert창은 실행되지 않습니다." );
}
```

## [첫 번째 falsy를 찾는 AND 연산자 ‘&&’](https://ko.javascript.info/logical-operators#ref-145)

아래는 AND 연산자와 피연산자가 여러 개인 경우다.

```javascript
result = value1 && value2 && value3;
```

AND 연산자 `&&`는 아래와 같은 순서로 동작한다.

- 가장 왼쪽 피연산자부터 시작해 오른쪽으로 나아가며 피연산자를 평가한다.
- 각 피연산자는 불린형으로 변환된다. 변환 후 값이 `false`이면 평가를 멈추고 해당 피연산자의 **변환 전** 원래 값을 반환한다.
- 피연산자 모두가 평가되는 경우(모든 피연산자가 `true`로 평가되는 경우)엔 마지막 피연산자가 반환된다.

`정리해 보자면, AND 연산자는 첫 번째 falsy를 반환한다. 피연산자에 falsy가 없다면 마지막 값을 반환한다.`

위 알고리즘은 OR 연산자의 알고리즘과 유사하다. 차이점은 AND 연산자가 첫 번째 *falsy*를 반환하는 반면, OR은 첫 번째 *truthy*를 반환한다는 것이다.

```javascript
// 첫 번째 피연산자가 truthy이면,
// AND는 두 번째 피연산자를 반환합니다.
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// 첫 번째 피연산자가 falsy이면,
// AND는 첫 번째 피연산자를 반환하고, 두 번째 피연산자는 무시합니다.
alert( null && 5 ); // null
alert( 0 && "아무거나 와도 상관없습니다." ); // 0
```

AND 연산자에도 피연산자 여러 개를 연속해서 전달할 수 있다.

```javascript
alert( 1 && 2 && null && 3 ); // null
```

아래 예시에선 AND 연산자의 피연산자가 모두 truthy이기 때문에 마지막 피연산자가 반환된다.

```javascript
alert( 1 && 2 && 3 ); // 마지막 값, 3
```

**`&&`의 우선순위가 `||`보다 높다.**

AND 연산자 `&&`의 우선순위는 OR 연산자 `||`보다 높다.

따라서 `a && b || c && d`는 `(a && b) || (c && d)`와 동일하게 동작한다.

**`if`를 ||나 &&로 대체하지 말자.**

```javascript
let x = 1;

(x > 0) && alert( '0보다 큽니다!' );
```

`&&`의 오른쪽 피연산자는 평가가 `&&` 우측까지 진행되어야 실행된다. 즉, `(x > 0)`이 참인 경우에만 `alert`문이 실행되는데,

위 코드를 if 문을 써서 바꾸면 다음과 같다.

```javascript
let x = 1;

if (x > 0) alert( '0보다 큽니다!' );
```

`&&`를 사용한 코드가 더 짧긴 하지만 `if`문을 사용한 예시가 코드에서 무엇을 구현하고자 하는지 더 명백히 드러내고, 가독성도 좋다. 그러니 if 조건문이 필요하면 `if`를 사용하고 AND 연산자는 연산자 목적에 맞게 사용하자.

## [! (NOT)](https://ko.javascript.info/logical-operators#ref-146)

논리 연산자 NOT은 느낌표 `!`를 써서 만들 수 있다. NOT 연산자의 문법은 매우 간단하다.

```javascript
result = !value;
```

NOT 연산자는 인수를 하나만 받고, 다음 순서대로 연산을 수행한다.

1. 피연산자를 불린형(`true / false`)으로 변환한다.
2. 1에서 변환된 값의 역을 반환한다.

```javascript
alert( !true ); // false
alert( !0 ); // true
```

**`NOT을 두 개 연달아 사용(`!!`)하면 값을 불린형으로 변환할 수 있습니다.`**

```javascript
alert( !!"non-empty string" ); // true
alert( !!null ); // false
```

이때, 첫 번째 NOT 연산자는 피연산자로 받은 값을 불린형으로 변환한 후 이 값의 역을 반환하고, 두 번째 NOT 연산자는 첫 번째 NOT 연산자가 반환한 값의 역을 반환한다. 이렇게 NOT을 연달아 사용하면 특정 값을 불린형으로 변환할 수 있다.

참고로, 내장 함수 `Boolean`을 사용하면 `!!`을 사용한 것과 같은 결과를 도출할 수 있다.

```javascript
alert( Boolean("non-empty string") ); // true
alert( Boolean(null) ); // false
```

**`NOT` 연산자의 우선순위는 모든 논리 연산자 중에서 가장 높기 때문에 항상 `&&`나 `||` 보다 먼저 실행된다.**

> **quiz** 
>
> 사이 범위 확인하기
>
> `age`(나이)가 `14`세 이상 `90`세 이하에 속하는지를 확인하는 `if`문을 작성하세요.
>
> "이상과 이하"는 `age`(나이) 범위에 `14`나 `90`이 포함된다는 의미입니다.
>
> 
>
> 해답
>
> ```javascript
> if (age >= 14 && age <= 90)
> ```
>
> **❗if (14 <= age <= 90) 식으로는 정상적으로 동작이 안되는 이유**
>
> > if문의 조건 14<=age<=90에서 연산자는 <=만 쓰였기 때문에, 동일한 연산자는 당연히 동일한 우선순위를 갖기 때문에 좌측부터 실행한다.
> >
> > 따라서 age값에 따라 14<=age는 true 또는 false를 반환한다. 14<=age의 결과값이 true 또는 false이므로 true <= 90, false <= 90
> > 두 가지 경우로 변환이 되고 비교 연산자를 실행하기 위해 형변환이 일어나 true는 1로 false는 0으로 형변환이 된다.
> >
> > 그렇기에, 1과 0 모두 90보다는 작거나 같기 때문에 age값에 무관하게 항상 '환영합니다'를 출력하게 된다.





#### 2.12 null 병합 연산자 '??'

**nullish coalescing operator(null 병합 연산자)**는 `??`를 사용하면 짧은 문법으로 여러 피연산자 중 그 값이 ‘확정되어있는’ 변수를 찾을 수 있다.

> `a ?? b`의 평가 결과는 다음과 같다.
>
> - `a`가 `null`도 아니고 `undefined`도 아니면 `a`
> - 그 외의 경우는 `b`

null 병합 연산자 `??`없이 `x = a ?? b`와 동일한 동작을 하는 코드를 작성하면 다음과 같다.

```javascript
x = (a !== null && a !== undefined) ? a : b;
```

또 다른 예시를 살펴봅시다. `firstName`, `lastName`, `nickName`이란 변수에 사용자 이름이나 별명을 저장하는데, 사용자가 아무런 정보도 입력하지 않는 케이스도 허용한다고 해보자.

화면엔 세 변수 중, 값이 정해진 변수의 값을 출력하는데, 세 변수 모두 값이 정해지지 않았다면 "Anonymous"가 출력되도록 해보자.

이럴 때 null 병합 연산자 `??`를 사용하면 값이 정해진 변수를 간편하게 찾아낼 수 있다.

```javascript
let firstName = null;
let lastName = null;
let nickName = "Supercoder";

// null이나 undefined가 아닌 첫 번째 피연산자
alert(firstName ?? lastName ?? nickName ?? "Anonymous"); // Supercoder
```

## ['??'와 '||'의 차이](https://ko.javascript.info/nullish-coalescing-operator#ref-691)

null 병합 연산자는 OR 연산자 `||`와 상당히 유사해 보인다. 실제로 위 예시에서 `??`를 `||`로 바꿔도 그 결과는 동일하기까지 하다. 하지만 두 연산자 사이에는 중요한 차이점이 있다.

- `||`는 첫 번째 *truthy* 값을 반환한다.
- `??`는 첫 번째 *정의된(defined)* 값을 반환한다.

`null`과 `undefined`, 숫자 `0`을 구분 지어 다뤄야 할 때 이 차이점은 매우 중요한 역할을 한다.

```javascript
height = height ?? 100;
```

`height`에 값이 정의되지 않았다면 `height`엔 `100`이 할당된다.

이제 `??`와 `||`을 비교해보자.

```javascript
let height = 0;

alert(height || 100); // 100
alert(height ?? 100); // 0
```

`height || 100`은 `height`에 `0`을 할당했지만 `0`을 falsy 한 값으로 취급했기 때문에 `null`이나 `undefined`를 할당한 것과 동일하게 처리된다. 따라서 `height || 100`의 평가 결과는 `100`이다.

반면 `height ?? 100`의 평가 결과는 `height`가 정확하게 `null`이나 `undefined`일 경우에만 `100`이 된다. 예시에선 `height`에 `0`이라는 값을 할당했기 때문에 얼럿창엔 `0`이 출력된다.

**이런 특징 때문에 높이처럼 `0`이 할당될 수 있는 변수를 사용해 기능을 개발할 땐 `||`보다 `??`가 적합하다.**

## [연산자 우선순위](https://ko.javascript.info/nullish-coalescing-operator#ref-692)

[`??`의 연산자 우선순위](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table)는 `5`로 꽤 낮다. 따라서 `??`는 `=`와 `?` 보다는 먼저, 대부분의 연산자보다는 나중에 평가된다.

그렇기 때문에 복잡한 표현식 안에서 `??`를 사용해 값을 하나 선택할 땐 괄호를 추가하는 게 좋다.

```javascript
let height = null;
let width = null;

// 괄호를 추가!
let area = (height ?? 100) * (width ?? 50);

alert(area); // 5000
```

그렇지 않으면 `*`가 `??`보다 우선순위가 높기 때문에 `*`가 먼저 실행된다.

```javascript
// 원치 않는 결과
let area = height ?? (100 * width) ?? 50;
```

`??`엔 자바스크립트 언어에서 규정한 또 다른 제약사항이 있다.

**안정성 관련 이슈 때문에 `??`는 `&&`나 `||`와 함께 사용하지 못한다.**

아래 예시를 실행하면 문법 에러가 발생한다.

```javascript
let x = 1 && 2 ?? 3; // SyntaxError: Unexpected token '??'
```

이 제약에 대해선 아직 논쟁이 많긴 하지만 사람들이 `||`를 `??`로 바꾸기 시작하면서 만드는 실수를 방지하고자 명세서에 제약이 추가된 상황이다.

제약을 피하려면 **괄호**를 반드시 사용하자.

```javascript
let x = (1 && 2) ?? 3; // 제대로 동작합니다.

alert(x); // 2
```

> [요약](https://ko.javascript.info/nullish-coalescing-operator#ref-693)
>
>null 병합 연산자 `??`를 사용하면 피연산자 중 ‘값이 할당된’ 변수를 빠르게 찾을 수 있다.
>
>`??`는 변수에 기본값을 할당하는 용도로 사용할 수 있다.
>
>``` // height가 null이나 undefined인 경우, 100을 할당
>height = height ?? 100;
>```
>
>`??`의 연산자 우선순위는 대다수의 연산자보다 낮고 `?`와 `=` 보다는 높다.
>
>괄호 없이 `??`를 `||`나 `&&`와 함께 사용하는 것은 금지되어 있다.

