#### 3.1 Chrome으로 디버깅하기

[디버깅(debugging)](https://en.wikipedia.org/wiki/Debugging)은 스크립트 내 에러를 검출해 제거하는 일련의 과정을 의미한다.

> 모던 브라우저와 호스트 환경 대부분은 개발자 도구 안에 UI 형태로 디버깅 툴을 구비해 놓는다. 디버깅 툴을 사용하면 디버깅이 훨씬 쉬워지고, 실행 단계마다 어떤 일이 일어나는지를 코드 단위로 추적할 수 있다.



## [‘Sources’ 패널](https://ko.javascript.info/debugging-chrome#ref-810)

> 1.Chrome을 사용해 [예시 페이지](https://ko.javascript.info/article/debugging-chrome/debugging/index.html)를 연다. 2.F12(MacOS: Cmd+Opt+I)를 눌러 개발자 도구를 연다. 3.Sources ` 탭을 클릭해 ` Sources` 패널(panel)을 연다.

Sources 패널을 처음 열었다면 아래와 같은 화면이 보인다.

![스크린샷 2021-04-25 오전 1 12 15](https://user-images.githubusercontent.com/79819941/115965317-8c5a3700-a563-11eb-9cc6-cedfdb978902.png)

토글 버튼 을 누르면 navigator가 열리면서 현재 사이트와 관련된 파일들이 나열된다.

파일 목록에서 `hello.js`를 클릭해 아래와 같이 화면을 바꿔본다.

![스크린샷 2021-04-25 오전 1 12 21](https://user-images.githubusercontent.com/79819941/115965328-a4ca5180-a563-11eb-9465-fb678ea00228.png)

Sources 패널은 크게 세 개의 영역으로 구성된다.

1. **파일 탐색 영역** – 페이지를 구성하는 데 쓰인 모든 리소스(HTML, JavaScript, CSS,  이미지 파일 등)를 트리 형태로 보여준다. Chrome 익스텐션이 여기 나타날 때도 있다.
2. **코드 에디터 영역** – 리소스 영역에서 선택한 파일의 소스 코드를 보여줍니다. 여기서 소스 코드를 편집할 수도 있다.
3. **자바스크립트 디버깅 영역** – 디버깅에 관련된 기능을 제공한다.

토글 버튼 을 다시 누르면 리소스 영역이 사라지고, 소스 코드 영역이 더 넓어진다.



## [콘솔](https://ko.javascript.info/debugging-chrome#ref-678)

Esc를 누르면 개발자 도구 하단부에 콘솔 창이 열린다. 여기에 명령어를 입력하고 Enter를 누르면 입력한 명령어가 실행된다.

콘솔 창에 구문(statement)을 입력하고 실행하면 아랫줄에 실행 결과가 출력된다.

`1+2`를 입력하면 `3`이 출력되고, `hello("debugger")`를 입력하면 `undefined`가 출력된다. `undefined`가 출력되는 이유는 `hello("debugger")`가 아무것도 반환하지 않기 때문이다.

![스크린샷 2021-04-25 오전 1 12 27](https://user-images.githubusercontent.com/79819941/115965340-bdd30280-a563-11eb-8883-233a692929e4.png)



## [중단점](https://ko.javascript.info/debugging-chrome#ref-679)

`hello.js`를 소스 코드 영역에 띄우고 네 번째 줄 코드 좌측의 줄 번호, `4`를 클릭해보자. 코드가 아닌 줄 번호 `4`에 마우스 커서를 옮긴 후 클릭해야 한다.

중단점을 성공적으로 설정하였다. 줄 번호 `8`도 클릭해 중단점을 하나 더 추가해보자.

줄 번호 `4`와 `8`이 파란색으로 바뀐 게 보인다면 정상적으로 잘 설정을 한 것이다.

![스크린샷 2021-04-25 오전 1 12 31](https://user-images.githubusercontent.com/79819941/115965355-d17e6900-a563-11eb-982e-cc34fd02536c.png)



*중단점(breakpoint)* 은 말 그대로 자바스크립트의 실행이 중단되는 코드 내 지점을 의미한다.

중단점을 이용하면 실행이 중지된 시점에 변수가 어떤 값을 담고 있는지 알 수 있다. 또한 실행이 중지된 시점을 기준으로 명령어를 실행할 수도 있다. 디버깅이 가능해지는 것이다.

Sources 패널 우측의 디버깅 영역을 보면 중단점 목록을 확인할 수 있다. 파일 여러 개에 다수의 중단점을 설정해 놓은 경우, 디버깅 영역을 이용하면 아래와 같은 작업을 할 수도 있다.

- 항목을 클릭해 해당 중단점이 설정된 곳으로 바로 이동할 수 있다.
- 체크 박스 선택을 해제해 해당 중단점을 비활성화 할 수 있다.
- 마우스 오른쪽 버튼을 클릭했을 때 나오는 ‘Remove breakpoint’ 옵션을 통해 중단점을 삭제할 수도 있다.
- 이 외에도 다양한 기능이 있다.

**조건부 중단점**

줄 번호에 커서를 옮긴 후 마우스 오른쪽 버튼을 클릭하면 *조건부 중단점(conditional breakpoint)* 을 설정할 수 있다. `Add conditional breakpoint`를 클릭했을 때 뜨는 작은 창에 표현식을 입력하면, 표현식이 참인 경우에만 실행을 중지시킬 수 있다.

조건부 중단점을 설정하면 변수에 특정 값이 할당될 때나 함수의 매개 변수에 특정 값이 들어올 때만 실행을 중단시킬 수 있어 디버깅 시 유용하게 활용할 수 있다.



## [debugger 명령어](https://ko.javascript.info/debugging-chrome#ref-680)

아래 예시처럼 스크립트 내에 `debugger` 명령어를 적어주면 중단점을 설정한 것과 같은 효과를 본다.

```javascript
function hello(name) {
  let phrase = `Hello, ${name}!`;

  debugger;  // <-- 여기서 실행이 멈춘다.

  say(phrase);
}
```

debugger 명령어를 사용하면 브라우저를 켜 개발자 도구를 열고 소스 코드 영역을 띄워 중단점을 설정하는 수고를 하지 않아도 된다. 에디터를 떠나지 않고도 중단점을 설정할 수 있기 때문에 편리하다.



## [멈추면 보이는 것들](https://ko.javascript.info/debugging-chrome#ref-681)

예시 페이지를 열면 함수 `hello()`가 자동으로 호출된다. 중단점이 제대로 설정되어있는지 확인하고, 새로 고침 단축키 F5(Windows, Linux 사용자)나 Cmd+R키(MacOS 사용자)를 눌러 중단점을 작동시켜보자.

아래 그림과 같이 네 번째 줄에서 실행이 중단되는 것을 확인할 수 있다.

![스크린샷 2021-04-25 오전 1 16 43](https://user-images.githubusercontent.com/79819941/115965384-0094da80-a564-11eb-8e41-c1f8952145c8.png)

이 상태에서 디버깅 영역의 `▼`를 클릭해 하위 패널들을 하나씩 펼쳐보면 각 패널은 아래와 같은 기능을 제공한다.

1. **`Watch` – 표현식을 평가하고 결과를 보여준다.**

   Add Expression 버튼 `+`를 클릭해 원하는 표현식을 입력한 후 Enter를 누르면 중단 시점의 값을 보여준다. 입력한 표현식은 실행 과정 중에 계속해서 재평가된다.

2. **`Call Stack` – 코드를 해당 중단점으로 안내한 실행 경로를 역순으로 표시한다.**

   실행은 `index.html` 안에서 `hello()`를 호출하는 과정 중에 멈췄다. 함수 `hello` 내에 중단점을 설정했기 때문에, 콜 스택(Call Stack) 최상단엔 `hello`가 위치합니다. `index.html`에서 함수 `hello`를 정의하지 않았기 때문에 콜 스택 하단엔 'anonymous’가 출력된다.

   콜 스택 내의 항목을 클릭하면 디버거가 해당 코드로 휙 움직이고, 변수 역시 재평가된다. 'anonymous’를 클릭해 직접 확인해 보자.

3. **`Scope` – 현재 정의된 모든 변수를 출력한다.**

   `Local`은 함수의 지역변수를 보여준다. 지역 변수 정보는 소스 코드 영역에서도 확인(강조 표시)할 수 있다.

   `Global`은 함수 바깥에 정의된 전역 변수를 보여준다.

   

## [실행 추적하기](https://ko.javascript.info/debugging-chrome#ref-682)

이제 본격적으로 실행 단계마다 어떤 일이 일어나는지 *추적* 해보겠다.

먼저, 디버깅 영역 상단에 있는 버튼들이 무슨 역할을 하는지 알아보자.

-  – ‘Resume’: 스크립트 실행을 다시 시작함 (단축키 F8)

  실행을 재개한다. 추가 중단점이 없는 경우, 실행이 죽 이어지고 디버거는 동작하지 않는다.버튼을 클릭해보자.

![스크린샷 2021-04-25 오전 1 16 52](https://user-images.githubusercontent.com/79819941/115965393-0db1c980-a564-11eb-9168-13b20215c2ad.png)

-  – ‘Step’: 다음 명령어를 실행함 (단축키 F9)

  다음 문을 실행합니다. 클릭하면 `alert` 창이 뜨는 것을 확인할 수 있다.Step 버튼을 계속 누르면 스크립트 전체를 문 단위로 하나하나 실행할 수 있다.

-  – ‘Step over’: 다음 명령어를 실행하되, *함수 안으로 들어가진 않음* (단축키 F10)

  'Step’과 유사하지만, 다음 문이 함수 호출일 때 'Step’과는 다르게 동작한다(`alert` 같은 내장함수에는 해당하지 않고, 직접 작성한 함수일 때만 동작이 다르다).'Step’은 함수 내부로 들어가 함수 본문 첫 번째 줄에서 실행을 멈춘다. 반면 'Step over’는 보이지 않는 곳에서 중첩 함수를 실행하긴 하지만 함수 내로 진입하지 않는다.실행은 함수 실행이 끝난 후에 즉시 멈춘다.'Step over’은 함수 호출 시 내부에서 어떤 일이 일어나는지 궁금하지 않을 때 유용하다.

-  – ‘Step into’ (단축키 F11)

  'Step’과 유사한데, 비동기 함수 호출에서 'Step’과는 다르게 동작한다. 이제 막 자바스크립트를 배우기 시작한 분이라면 비동기 호출에 대해 아직 배우지 않았기 때문에 'Step’과 'Step into’의 차이를 몰라도 괜찮다.'Step’은 `setTimeout`(함수 호출 스케줄링에 쓰이는 내장 메서드)같은 비동기 동작은 무시한다. 반면 'Step into’는 비동기 동작을 담당하는 코드로 진입하고, 필요하다면 비동기 동작이 완료될 때까지 대기한다. 자세한 내용은 [개발자 도구 매뉴얼](https://developers.google.com/web/updates/2018/01/devtools#async)에서 확인하시기 바란다.

-  – ‘Step out’: 실행 중인 함수의 실행이 끝날 때 까지 실행을 계속함 (단축키 Shift+F11)

  현재 실행 중인 함수의 실행을 계속 이어가다가 함수 본문 마지막 줄에서 실행을 멈춘다. 실수로 을 눌러 내부 동작을 알고 싶지 않은 중첩 함수로 진입했거나 가능한 한 빨리 함수 실행을 끝내고 싶은 경우 유용하다,

-  – 모든 중단점을 활성화/비활성화

  모든 중단점을 일시적으로 활성화/비활성화한다(실행에는 영향이 없다).

-  – 예외 발생 시 코드를 자동 중지시켜주는 기능을 활성화/비활성화

  활성화되어 있고, 개발자 도구가 열려있는 상태에서 스크립트 실행 중에 에러가 발생하면 실행이 자동으로 멈춘다. 실행이 중단되었기 때문에 변수 등을 조사해 어디서 에러가 발생했는지 찾을 수 있게 된다. 개발하다가 에러와 함께 스크립트가 죽었다면 디버거를 열고 이 옵션을 활성화한 후, 페이지를 새로 고침하면 에러가 발생한 곳과 에러 발생 시점의 컨텍스트를 확인할 수 있다.

**Continue to here 옵션**

특정 줄에서 마우스 오른쪽 버튼을 클릭해 컨텍스트 메뉴를 열면 "Continue to here"라는 옵션을 볼 수 있다.

중단점을 설정하기는 귀찮은데 해당 줄에서 실행을 재개하고 싶을 때 아주 유용한 옵션이다.



## [console.log](https://ko.javascript.info/debugging-chrome#ref-683)

`console.log` 함수를 이용하면 원하는 것을 콘솔에 출력할 수 있다.

아래 예시를 실행하면 콘솔창에 `0`부터 `4`까지 출력된다.

```javascript
// 콘솔창을 열어 결과를 확인해 보세요.
for (let i = 0; i < 5; i++) {
  console.log("숫자", i);
}
```

결과는 콘솔창에만 있기 때문에 일반 사용자는 결과를 볼 수 없다. 결과를 보려면 개발자 도구의 콘솔 패널을 직접 열거나 다른 패널이 열린 상태에서 Esc를 눌러 화면 하단에 콘솔 패널을 띄우면 된다.

코드에 `console.log`를 적절히 넣어주었다면 디버거 없이도 무슨 일이 일어나고 있는지 충분히 파악할 수 있으므로, `console.log` 함수와 디버거를 적절히 활용하자.



> ## [요약](https://ko.javascript.info/debugging-chrome#ref-684)
>
> 스크립트 실행이 중단되는 경우는 다음과 같다.
>
> 1. 중단점을 만났을 때
> 2. `debugger`문 만났을 때
> 3. 에러가 발생했을 때(개발자 도구가 열려있고 버튼이 '활성화’되어있는 경우)
>
> 스크립트 실행이 중지되면 중단 시점을 기준으로 변수에 어떤 값이 들어가 있는지 확인할 수 있다. 또한 단계별로 코드를 실행해 가며, 어디서 문제가 발생했는지 추적할 수도 있다. 이런 식으로 디버깅이 진행된다.
>
> 개발자 도구는 여기서 소개한 기능 이외의 다양한 기능을 지원한다. Google에서 제공하는 개발자 도구 공식 매뉴얼은 https://developers.google.com/web/tools/chrome-devtools에서 확인할 수 있다.
>
> 이번 챕터에서 배운 내용만으로도 디버깅을 충분히 할 수 있다. 그런데 나중에 브라우저 고급 기능을 배운 후에는 개발자 도구 공식 매뉴얼에 들어가 더 많은 개발자 도구 기능에 대해 알아보자.
>
> 개발자 도구를 열어 이것저것 클릭하면서 어떤 것들이 나타나는지 살펴보는 방법도 좋다. 직접 부딪쳐 보는 게 가장 빠른 학습 방법일 수 있으니까. 마우스 오른쪽 버튼을 클릭해 컨텍스트 메뉴를 띄워보는 것도 잊지 말자!



#### 3.2 코딩 스타일

개발자는 가능한 한 간결하고 읽기 쉽게 코드를 작성해야 한다.

복잡한 문제를 간결하고 사람이 읽기 쉬운 코드로 작성해 해결하는 것이야말로 진정한 프로그래밍 기술이다. 좋은 코드 스타일은 이런 기술을 연마하는 데 큰 도움을 준다.



## [문법](https://ko.javascript.info/coding-style#ref-177)

몇 가지 추천할만한 규칙을 아래 치트 시트에 표시해보았다(자세한 설명은 아래를 참고).

![스크린샷 2021-04-25 오전 12 40 03](https://user-images.githubusercontent.com/79819941/115964322-d68ce980-a55e-11eb-9f6e-0f34870f761c.png)

**‘무조건’  따라야 할 규칙이란 건 없다.**



### [중괄호](https://ko.javascript.info/coding-style#ref-178)

대부분의 자바스크립트 프로젝트에서 여는 중괄호는 ‘이집션(Egyptian)’ 스타일을 따라 새로운 줄이 아닌 상응하는 키워드와 같은 줄에 작성한다. 여기에 더하여 여는 중괄호 앞엔 아래와 같이 공백이 하나 있어야 한다.

```javascript
if (condition) {
  // 코드 1
  // 코드 2
  // ...코드 n...
}
```

`if (condition) doSomething()`과 같은 단 한 줄짜리 구문은 중요하게 다뤄야 할 에지 케이스다. 

어떻게 코드를 작성해야 가독성이 좋을지 직접 판단해 보시라고 주석과 함께 몇 가지 예시를 만들어보았다.

1. 😠 초보 개발자들은 아래처럼 코드를 작성하곤 하는데, 중괄호가 필요하지 않기 때문에 추천하지 않는다.

   ```javascript
   if (n < 0) {alert(`Power ${n} is not supported`);}
   ```

2. 😠 중괄호 없이 새로운 줄에 코드를 작성할 수도 있는데, 이렇게 하면 새로운 코드 라인을 추가할 때 에러가 발생합니다. 절대 이 방법은 쓰지 말자.

   ```javascript
   if (n < 0)
     alert(`Power ${n} is not supported`);
   ```

3. 😏 코드가 짧다면 중괄호 없이 한 줄에 쓰는 방법도 나쁘진 않다.

   ```javascript
   if (n < 0) alert(`Power ${n} is not supported`);
   ```

4. 😃 가장 추천하는 방법은 다음과 같다.

   ```javascript
   if (n < 0) {
     alert(`Power ${n} is not supported`);
   }
   ```

`if (cond) return null`처럼 코드가 간단하다면 세 번째 예시같이 한 줄에 몰아서 작성해도 괜찮다. 그렇지만 네 번째 예시처럼 코드 블록을 사용하는 방법이 가장 가독성이 좋으므로 이 방법을 추천한다.



### [가로 길이](https://ko.javascript.info/coding-style#ref-179)

가로로 길게 늘어진 코드를 읽는 걸 좋아하는 개발자는 없다. 코드의 가로 길이가 길어진다면 여러 줄로 나눠 작성하는 게 좋다.

예시:

```javascript
// 백틱(`)을 사용하면 문자열을 여러 줄로 쉽게 나눌 수 있다.
let str = `
  ECMA International's TC39 is a group of JavaScript developers,
  implementers, academics, and more, collaborating with the community
  to maintain and evolve the definition of JavaScript.
`;
```

`if`문이라면 아래와 같이 작성할 수 있다.

```javascript
if (
  id === 123 &&
  moonPhase === 'Waning Gibbous' &&
  zodiacSign === 'Libra'
) {
  letTheSorceryBegin();
}
```

최대 가로 길이는 팀원들과 합의해 정하는게 좋다. 대개 80자나 120자로 제한하는 게 일반적이다.



### [들여쓰기](https://ko.javascript.info/coding-style#ref-180)

들여쓰기에는 두 종류가 있다.

- **가로 들여쓰기: 스페이스 두 개 혹은 네 개를 사용해 만들기**

  가로 들여쓰기는 스페이스 두 개 혹은 네 개를 사용하거나 탭 키(Tab)를 이용해 만들 수 있다. 어떤 방법을 쓸지에 대한 논쟁은 오래전부터 있었는데, 요즘엔 탭 대신 스페이스를 이용하는 게 더 우위에 있는 것 같다.

  탭 대신 스페이스를 이용했을 때의 장점 중 하나는 들여쓰기 정도를 좀 더 유연하게 변경할 수 있다는 점이다.

  아래 예시처럼 인수 모두의 위치를 여는 괄호와 맞출 수 있다.

  ```javascript
  show(parameters,
       aligned, // 스페이스 다섯 개를 이용해 들여쓰기 함
       one,
       after,
       another
    ) {
    // ...
  }
  ```

- **세로 들여쓰기: 논리 블록 사이에 넣어 코드를 분리해주는 새 줄**

  함수 하나에 논리 블록 여러 개가 들어갈 수 있다. 아래 예시에서 변수 선언, 반복문, 리턴문 사이에 세로 들여쓰기를 해주는 빈 줄을 넣어 코드를 분리해 보았다.

  ```javascript
  function pow(x, n) {
    let result = 1;
    //              <--
    for (let i = 0; i < n; i++) {
      result *= x;
    }
    //              <--
    return result;
  }
  ```

  이렇게 여분의 줄을 넣어주면 코드의 가독성이 좋아진다. 읽기 쉬운 코드를 만들려면 세로 들여쓰기 없이 코드를 아홉 줄 이상 연속해서 쓰지 말자.

  

### [세미콜론](https://ko.javascript.info/coding-style#ref-181)

**자바스크립트 엔진에 의해 무시되더라도 모든 구문의 끝엔 세미콜론을 써주는 것이 좋다.**

구문 끝에 세미콜론을 적는 게 완전히 선택사항인 언어가 몇몇 있는데 이런 언어들에선 세미콜론을 잘 쓰지 않는다. 그러나 자바스크립트에선 줄 바꿈이 세미콜론으로 해석되지 않는 몇몇 상황이 있기 때문에 세미콜론을 생략하고 코딩하는 습관을 들이면 에러를 발생시키는 코드를 만들 수 있다. 

경험이 많은 자바스크립트 개발자라면 [StandardJS](https://standardjs.com/)에서 제시하는 스타일 가이드처럼 세미콜론 없이 코드를 작성할 수도 있다. 초보 개발자라면 에러를 만들 확률을 줄이기 위해서라도 세미콜론을 사용하는 게 좋다.



### [중첩 레벨](https://ko.javascript.info/coding-style#ref-182)

가능하면 너무 깊은 중첩문은 사용하지 않도록 해야한다.

반복문을 사용할 때 중첩문의 깊이가 깊어지면 [`continue`](https://ko.javascript.info/while-for#continue) 지시자를 쓰는 게 좋은 대안이 될 수도 있다.

`if`문으로 조건을 처리하는 예시를 통해 이를 살펴본다.

```javascript
for (let i = 0; i < 10; i++) {
  if (cond) {
    ... // <- 중첩 레벨이 하나 더 늘어났다.
  }
}
```

위 코드는 `continue`를 써서 아래와 같이 바꿀 수 있다.

```javascript
for (let i = 0; i < 10; i++) {
  if (!cond) continue;
  ...  // <- 추가 중첩 레벨이 추가되지 않는다.
}
```

`if/else`와 `return`문을 조합하면 위 예시와 유사하게 중첩 레벨을 줄여 코드의 가독성을 높일 수 있다.

아래 두 예시는 동일하게 동작한다.

예시 1:

```javascript
function pow(x, n) {
  if (n < 0) {
    alert("'n'은 음수가 될 수 없습니다.");
  } else {
    let result = 1;

    for (let i = 0; i < n; i++) {
      result *= x;
    }

    return result;
  }
}
```

예시 2:

```javascript
function pow(x, n) {
  if (n < 0) {
    alert("'n'은 음수가 될 수 없습니다.");
    return;
  }

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

`n < 0`인 '특별한 상황’을 앞에 두고, 그 안에 `return`문을 추가해주었더니 가독성이 훨씬 좋아졌다. 특별한 상황인지를 확인하고 조건을 통과하면 추가 중첩 없이 ‘주요’ 코드 흐름으로 넘어가게 코드를 짰기 때문이다.



## [함수의 위치](https://ko.javascript.info/coding-style#ref-183)

‘헬퍼’ 함수(다른 함수 안에서 특정 기능을 하고 있는 함수) 여러 개를 만들어 사용하고 있다면 아래와 같은 방법을 사용해 코드 구조를 정돈할 수 있다.

1. 헬퍼 함수를 사용하는 코드 *위*에서 헬퍼 함수를 모아 선언하기

   ```javascript
   // 함수 선언
   function createElement() {
     ...
   }
   
   function setHandler(elem) {
     ...
   }
   
   function walkAround() {
     ...
   }
   
   // 헬퍼 함수를 사용하는 코드
   let elem = createElement();
   setHandler(elem);
   walkAround();
   ```

2. 코드를 먼저, 함수는 그 다음에 선언하기

   ```javascript
   // 헬퍼 함수를 사용하는 코드
   let elem = createElement();
   setHandler(elem);
   walkAround();
   
   // --- 헬퍼 함수 ---
   function createElement() {
     ...
   }
   
   function setHandler(elem) {
     ...
   }
   
   function walkAround() {
     ...
   }
   ```

3. 혼합: 코드 바로 위에서 필요한 헬퍼 함수 그때그때 선언하기

**대개는 두 번째 방법으로 코드를 정돈하는 걸 선호한다.**

사람들은 이 코드가 '무엇을 하는지’를 생각하며 코드를 읽기 때문에 코드가 먼저 나오는 것이 자연스럽기 때문이다. 이름만 보고도 헬퍼 함수의 역할을 쉽게 유추할 수 있게 헬퍼 함수 이름을 명명했다면 함수 본문을 읽을 필요도 없다.



## [스타일 가이드](https://ko.javascript.info/coding-style#ref-184)

코딩 스타일 가이드는 코드를 '어떻게 작성할지’에 대한 전반적인 규칙을 담은 문서로, 어떤 따옴표를 쓸지, 들여쓰기할 때 스페이스를 몇 개 사용할지, 최대 가로 길이는 몇까지 제한할지 등의 내용이 담겨있다.

팀원 전체가 동일한 스타일 가이드를 따라 코드를 작성하면, 누가 코드를 작성했나에 관계없이 동일한 스타일의 코드를 만들 수 있다.

팀원들이 모여 팀 전용 스타일 가이드를 만들 수도 있는데, 요즘엔 이미 작성된 가이드 중 하나를 선택해 팀의 가이드로 삼는 편이다.

유명 스타일 가이드:

- [Google의 자바스크립트 스타일 가이드](https://google.github.io/styleguide/jsguide.html)

- [Airbnb의 자바스크립트 스타일 가이드](https://github.com/airbnb/javascript)

- [Idiomatic.JS](https://github.com/rwaldron/idiomatic.js)

- [StandardJS](https://standardjs.com/)

  



## [Linter](https://ko.javascript.info/coding-style#ref-185)

Linter: 내가 작성한 코드가 스타일 가이드를 준수하고 있는지를 자동으로 확인할 수 있고, 스타일 개선과 관련된 제안도 받을 수 있는 도구.

자동으로 스타일을 체크받다 보면, 변수나 함수 이름에 난 오타 등이 유발하는 버그를 미리 발견할 수 있어서 유용하다. 

아직 '코드 스타일’을 정하지 않았더라도 linter를 사용하면 버그를 예방할 수 있기 때문에 linter 사용을 권장한다.

유명 linter:

- [JSLint](http://www.jslint.com/) – 역사가 오래된 linter
- [JSHint](http://www.jshint.com/) – JSLint보다 세팅이 좀 더 유연한 linter
- [ESLint](http://eslint.org/) – 가장 최근에 나온 linter

위 linter 모두 훌륭한 기능을 제공합니다. 글쓴이는 [ESLint](http://eslint.org/)를 사용하고 있다.

대부분의 linter는 플러그인 형태로 유명 에디터와 통합해 사용할 수 있고, 원하는 스타일을 설정하는 것 역시 가능하다.

ESLint를 사용한다고 가정했을 때 아래 절차를 따르면 에디터와 linter를 통합해 사용할 수 있다.

1. [Node.js](https://nodejs.org/)를 설치.
2. npm(자바스크립트 패키지 매니저)을 사용해 다음 명령어로 ESLint를 설치. `npm install -g eslint`
3. 현재 작성 중인 자바스크립트 프로젝트의 루트 폴더(프로젝트 관련 파일이 담긴 폴더)에 `.eslintrc`라는 설정 파일을 생성.
4. 에디터에 ESLint 플러그인을 설치하거나 활성화. 주요 에디터들은 모두 ESLint 플러그인을 지원함.

아래는 `.eslintrc` 파일의 예시이다.

```javascript
{
  "extends": "eslint:recommended",
  "env": {
    "browser": true,
    "node": true,
    "es6": true
  },
  "rules": {
    "no-console": 0,
    "indent": ["warning", 2]
  }
}
```

위 예시에서 지시자 `"extends"`는 "eslint:recommended"를 기반으로 이를 확장해 스타일 가이드를 설정하겠다는 걸 의미하며, 이렇게 세팅한 이후에 자신만의 스타일을 설정하면 된다.

스타일 규칙을 모아놓은 세트를 웹에서 다운로드해 이를 기반으로 스타일 가이드를 설정하는 것도 가능하다. 

몇몇 IDE에서는 자체 lint 도구가 있어 편리하긴 하지만 ESLint처럼 쉽게 설정을 변경하는 게 불가능하다는 단점도 있다.



>## [요약](https://ko.javascript.info/coding-style#ref-186)
>
>문법 규칙과 스타일 가이드 관련 참고자료들은 코드 가독성을 높이기 위해 만들어졌다.
>
>‘더 좋은’ 코드를 만들려면 "가독성이 좋고 이해하기 쉬운 코드를 만들려면 무엇을 해야 할까?"라는 질문과 "에러를 피하려면 어떤 일을 해야 할까?"라는 질문을 스스로에게 던져야 한다. 
>
>어떤 코딩 스타일을 따를지 결정할 때와 이에 대한 논쟁을 할 땐 이런 질문을 기반으로 해야 하기 때문이다.
>
>유명 스타일 가이드를 읽다 보면 코드 스타일에 관한 경향과 모범 사례에 대한 최신 정보를 유지할 수 있다.



#### 3.3 주석

한 줄짜리 주석은 `//`로, 여러 줄의 주석은 `/* ... */`로 시작하며, 주석(comment)은 어떻게 코드가 동작하는지, 왜 코드가 동작하는지를 설명하는 데 쓰인다. 주석을 작성하는 게 쉬워 보일 수 있는데, 초보 개발자들은 종종 잘못된 방법으로 주석을 작성하는 실수를 범한다.



## [좋지 않은 주석](https://ko.javascript.info/comments#ref-181)

초심자들은 주석에 '코드에서 무슨 일이 일어나는지’에 대한 내용을 아래와 같이 작성을 한다.

```javascript
// 이 코드는 (...)과 (...)을 수행합니다
// A라는 개발자가 이 기능에 대해 알고 있으며...
very;
complex;
code;
```

그러나 좋은 코드엔 ‘설명이 담긴(explanatory)’ 주석이 많아선 안 된다. 주석 없이 코드 자체만으로 코드가 무슨 일을 하는지 쉽게 이해할 수 있어야 한다.

“코드가 불분명해서 주석 작성이 불가피하다면 코드를 다시 작성해야 하는 지경에 이른 걸 수 있어 이와 관련된 좋은 규칙도 있다. ”



### [리팩토링 팁: 함수 분리하기](https://ko.javascript.info/comments#ref-182)

함수 내 코드 일부를 새로운 함수로 옮기는 게 아래와 같이 유익할 때도 있다. 

```javascript
function showPrimes(n) {
  nextPrime:
  for (let i = 2; i < n; i++) {

    // i가 소수인지를 확인함
    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert(i);
  }
}
```

코드 일부를 함수 `isPrime`으로 옮기면 더 나은 코드를 작성할 수 있다.

```javascript
function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;

    alert(i);
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if (n % i == 0) return false;
  }

  return true;
}
```

함수 이름 자체가 주석 역할을 하므로 코드를 쉽게 이해할 수 있게 되었다. 이런 코드를 *자기 설명적인(self-descriptive)* 코드라 부른다.



### [리팩토링 팁: 함수 만들기](https://ko.javascript.info/comments#ref-183)

아래와 같이 코드가 ‘아래로 죽 늘어져 있는’ 경우를 생각해 보자.

```javascript
// 위스키를 더해줌
for(let i = 0; i < 10; i++) {
  let drop = getWhiskey();
  smell(drop);
  add(drop, glass);
}

// 주스를 더해줌
for(let t = 0; t < 3; t++) {
  let tomato = getTomato();
  examine(tomato);
  let juice = press(tomato);
  add(juice, glass);
}

// ...
```

이럴 땐 새로운 함수를 만들고, 아래처럼 코드 일부를 새로 만든 함수에 옮기는 게 좋다. 

```javascript
addWhiskey(glass);
addJuice(glass);

function addWhiskey(container) {
  for(let i = 0; i < 10; i++) {
    let drop = getWhiskey();
    //...
  }
}

function addJuice(container) {
  for(let t = 0; t < 3; t++) {
    let tomato = getTomato();
    //...
  }
}
```

함수는 주석이 없어도 그 존재 자체가 무슨 역할을 하는지 설명할 수 있어야 한다. 코드를 분리해 작성하면 더 나은 코드 구조가 된다. 이런 가이드를 잘 지켜 코드를 작성하면 함수가 어떤 동작을 하는지, 무엇을 받고 무엇을 반환하는지가 명확해진다.

그런데 실무에선, ‘설명이 담긴’ 주석을 작성하는 게 불가피한 경우도 있다. 알고리즘이 복잡한 코드를 작성하는 경우나 최적화를 위해 코드를 약간 비틀어 작성할 땐 설명을 적어주어야 한다. 이런 경우를 제외하곤 간결하고 코드 자체만으로 설명이 가능하게 코딩해야 한다.



## [좋은 주석](https://ko.javascript.info/comments#ref-184)

설명이 담긴 주석은 대개 좋지 않다는데, 그럼 좋은 주석이란 무엇일까?

- 아키텍처를 설명하는 주석

  고차원 수준 컴포넌트 개요, 컴포넌트 간 상호작용에 대한 설명, 상황에 따른 제어 흐름 등은 주석에 넣는 게 좋다. 이런 주석은 조감도 역할을 해준다. 

- 함수 용례와 매개변수 정보를 담고 있는 주석

  [JSDoc](http://en.wikipedia.org/wiki/JSDoc)이라는 특별한 문법을 사용하면 함수에 관한 문서를 쉽게 작성할 수 있다. 여기엔 함수 용례, 매개변수, 반환 값 정보가 들어간다.

예시:

```javascript
/**
 * x를 n번 곱한 수를 반환함
 *
 * @param {number} x 거듭제곱할 숫자
 * @param {number} n 곱할 횟수, 반드시 자연수여야 함
 * @return {number} x의 n 거듭제곱을 반환함
 */
function pow(x, n) {
  ...
}
```

이렇게 주석을 달면 코드를 읽어보지 않고도 함수의 목적과 사용법을 한눈에 알 수 있다.

[WebStorm](https://www.jetbrains.com/webstorm/) 등의 다양한 에디터는 이런 주석을 이용해 자동 완성 기능, 자동 에러 검출 기능 등을 제공한다.

[JSDoc 3](https://github.com/jsdoc3/jsdoc)이나 기타 유사한 툴을 사용하면 주석으로 HTML 문서를 만들 수 있다. 자세한 정보는 http://usejsdoc.org/에서 확인 해볼 수 있다.

- 왜 이런 방법으로 문제를 해결했는지를 설명하는 주석

  무엇이 적혀있는지는 중요하다. 그런데 무슨 일이 일어나고 있는지 파악하려면 무엇이 *적혀있지 않은 지*가 더 중요할 수 있다. '왜 이 문제를 이런 방법으로 해결했나?'라는 질문에 코드는 답을 해 줄 수 없기 때문이다.문제 해결 방법이 여러 가지인데 왜 하필이면 이 방법을 택했는지 의문이 들 때가 있다. 선택한 방법이 가장 나은 것도 아닌데 말이죠.왜 이런 방법을 써서 문제를 해결했는지 알려주는 주석이 없으면 다음과 같은 일이 발생할 수 있다.당신(혹은 동료)은 작성된 후 시간이 꽤 흐른 코드를 열어보자. 그리고 그 코드에서 선택한 방식이 ‘가장 좋은 방식은 아니란 걸’ 알아내게 된다."그때는 내가 멍청했구나. 하지만 지금은 더 똑똑해졌지"라고 생각하며, 이전보단 ‘더 명확하고 올바른’ 방법으로 코드를 개선하게 된다. 코드를 개선하려는 시도까지는 좋았지만 리팩토링 과정에서 '더 명확’하다고 생각했던 방법을 적용하면 문제가 발생한다는 걸 알아내게 된다. 이미 시도해봤던 방법이기 때문에 왜 이 방법이 먹히지 않는지 희미하게 기억이 떠오른다. 새로 작성한 코드를 되돌렸지만, 시간이 낭비되었다. 

  **이전에 했던 실수를 방지하는 안내판 역할을 하기 때문에 해결 방법을 담고 있는 주석은 아주 중요한 역할을 합니다. **

- 미묘한 기능이 있고, 이 기능이 어디에 쓰이는지를 설명하는 주석

  직감에 반하는 미묘한 동작을 수행하는 코드가 있다면 주석을 달아주는 게 좋다.



> ## [요약](https://ko.javascript.info/comments#ref-185)
>
> 주석을 보면 좋은 개발자인지 아닌지를 어느 정도 알 수 있다. 주석을 언제 쓰고 언제 쓰지 않는지를 보면 된다.
>
> 주석을 잘 작성해 놓으면 시간이 지난 후 코드를 다시 살펴볼 때 효율적으로 정보를 얻을 수 있고, 특히 코드 유지보수에 도움이 된다.
>
> **주석에 들어가면 좋은 내용**
>
> - 고차원 수준 아키텍처
> - 함수 용례
> - 당장 봐선 명확해 보이지 않는 해결 방법에 대한 설명
>
> **주석에 들어가면 좋지 않은 내용**
>
> - '코드가 어떻게 동작하는지’와 '코드가 무엇을 하는지’에 대한 설명
> - 코드를 간결하게 짤 수 없는 상황이나 코드 자체만으로도 어떤 일을 하는지 충분히 판단할 수 없는 경우에만 주석을 넣자.
>
> 주석은 JSDoc3 같은 자동 문서생성 도구에도 쓰인다. 자동 문서생성 도구는 주석을 이용해 HTML 등의 포맷을 가진 문서를 자동으로 만들어준다.





#### 3.4 닌자 코드

**⚠️ 참고로 해당 챕터는 반어법으로 작성된 챕터였다. 즉, 저렇게 하면 안된다는 거다.**



> 생각 없이 배우기만 하면 얻는 것이 없고,
> 생각만 하고 배우지 않으면 오류나 독단에 빠질 위험이 있다.
>
> 공자



## [코드 짧게 쓰기](https://ko.javascript.info/ninja-code#ref-1060)

지엽적인 문법 지식 등을 총동원하면 코드 양을 획기적으로 줄일 수 있다.

조건부 연산자 `'?'`를 사용한 예시를 살펴보자.

```javascript
// 출처: 아주 유명한 라이브러리
i = i ? i < 0 ? Math.max(0, len + i) : i : 0;
```

`i`가 나타내는 게 뭔지 파악하는데 꽤 많은 시간을 소모하고, 결국엔 답을 찾지 못해 당신을 찾아올 것이다.



## [글자 하나만 사용하기](https://ko.javascript.info/ninja-code#ref-1061)

> 도는 숨어서 이름도 없지만, 오직 도만이 스스로를 잘 빌려주고 만물이 성하도록 돕는다.
>
> 노자(도덕경)



 `a`, `b`, `c`처럼 글자 하나만 사용해서 변수 이름을 만들자. 

그 누구도 변수를 찾을 수 없게 된다. 코드 에디터의 "검색"기능도 통하지 않는다. 어렵사리 변수가 정의된 곳을 찾더라도 변수 `a`나 `b`가 무엇을 의미하는지 절대 "해석"할 수 없게 된다.



## [약어 사용하기](https://ko.javascript.info/ninja-code#ref-1062)

팀에 한 글자 짜리 변수나 모호한 변수명을 사용하지 못하게 하는 제약이 있다면 약어를 쓰는 기지를 발휘하자. 변수명은 짧을수록 좋다.

예시:

- `list` → `lst`.
- `userAgent` → `ua`.
- `browser` → `brsr`.
- 등등…

모든 걸 줄여서 당신의 코드를 읽을 가치가 있는 직감이 뛰어난 개발자만 유지보수를 담당 할 수 있게 해 놓아야한다.



## [포괄적인 명사 사용하기](https://ko.javascript.info/ninja-code#ref-1063)

> 네모가 아주 크면 마치 모서리가 없는 것처럼 보이며,
> 큰 그릇은 천천히 만들어지고,
> 소리가 너무 크면 들리지 않는 것 같고,
> 거대한 형상은 형태가 없다.
>
> 노자(도덕경)



무언가를 명명할 땐 `obj`, `data`, `value`, `item`, `elem` 같이 다양한 개념을 포괄할 수 있는 명사를 사용하자. 포괄하는 개념이 많은 명사일수록 더 좋다.

- **`data`는 가장 이상적인 변수명이다.** 가능한 모든 곳에서 이 변수명을 사용하자. 변수가 실제로 담고 있는 건 *데이터*니까.

  그런데 변수명 `data`가 이미 선점된 상황이라면 어떻게 해야 할까? 그럴 땐 `value`를 사용하면 된다. 이 단어 역시 추상도가 높아서 많은 개념을 포함할 수 있고, 변수에 *값(value)* 이 저장된다는 건 변함없는 사실이니까.

- **`str`, `num` 같이 자료형과 연관된 변수명을 사용하자.**

  **이렇게 변수명을 만들면 누군가 당신의 코드를 봤을 때, 어떤 것도 유추할 수 없게 된다!** 작성자 당신만 자료형 정보를 보고 어떤 값이 저장될지 유추 할 수 있다. 그 누구도 해석할 수 없는 변수가 만들어졌다. 

  사실 자료형을 파악하는 건 식은 죽 먹기다. 디버깅 툴을 사용하면 된다. 그런데 변수의 의미는 파악이 쉽지 않다. 변수 `str`이나 `num`이 실제 어떤 의미를 가진 변수인지 코드만 보고는 쉽게 알 수 없다.

  독심술을 배우지 않는 이상 그 누구도 당신이 작성한 변수의 의미를 파악할 수 없게 된다.

- **새로운 변수명이 더는 떠오르지 않는다면 어떻게 해야 할까?** `data1, item2, elem5` 처럼 옆에 숫자를 붙여주면 된다.



## [철자가 유사한 단어 사용하기](https://ko.javascript.info/ninja-code#ref-1064)

여러 가지 방법이 있는데 그중 하나는 **`date`와 `data`같이 유사한 철자를 가진 단어를 조합해 사용하는 거다.**

**이렇게 작성해 놓으면 닌자조차도 자신이 작성한 코드를 읽는 데 시간이 많이 소모될 것이다. **

## [동의어 사용하기](https://ko.javascript.info/ninja-code#ref-1065)

> 모든 일 중 가장 어려운 일은
> 어두운 방에서 검은 고양이를 찾는 일이다.
>
> 특히 그 방에 고양이가 없을 때에.
>
> 공자



스크린에 메시지를 보여주는(display) 동작을 수행하는 함수라면 접두어 `display…`를 사용해 `displayMessage`라고 이름을 짓고, 사용자 이름(user name)을 화면에 보여주는(show) 함수는 접두어 `show…`를 써 `showName`이라고 이름 지으면 좋다.

코드를 읽는 사람이 메시지를 보여주는 것과 사용자 이름을 보여주는 것에 실제론 아무 의미가 없지만, 미묘한 차이가 있을 것 같다고 착각하게 해야 한다. 

무언가를 “보여주는(showing)” 함수를 만든다고 가정했을 때, John이 접두어 `display...`를 사용했다면, Peter는 다른 접두어 `render..`를, Ann은 또 다른 접두어 `paint...`를 사용하게끔 하자.

프린터(printer)를 사용하는 함수는 `printPage(page)`, 화면에 문자(text)를 출력(print)해 주는 함수는 `printText(text)`라고 명명하면 된다.

`printMessage`라는 함수를 보았을 때 "이 함수는 어디에 메시지를 출력하는 걸까? 프린터를 이용해 메시지를 출력하는 걸까? 아니면 그냥 화면에 메시지를 출력해주는 걸까?"라고 생각하게 하자. 함수 `printMessage(message)`가 새 창에 메시지를 띄우는 동작을 담당한다면 훈련 강도는 더 높아질 것이다.



## [이름 재사용하기](https://ko.javascript.info/ninja-code#ref-1066)

> 무언가를 만들기 시작하면,
> 그에 걸맞은 이름이 생기니,
> 이미 이름이 있다면,
> 무릇 멈출 줄 알아야 하고,
> 멈출 줄 알면 위태롭지 않을 수 있다.
>
> 노자(도덕경)



변수 선언은 정말 필요한 경우에만 하자.

새로운 값을 저장할 때 기존 변수를 활용하면, 변수 선언을 최대한 피할 수 있다.

함수를 구현 중이라면 내부 변수를 선언하지 않고, 매개변수에서 넘어온 값만 사용하자.

변수에 *현재* 어떤 값이 들어가 있는지, 값의 유래는 어디인지 쉽게 파악하지 못하게 술수를 부려 개발자의 직관력과 암기력을 높여줍시다. **이름을 재사용하면 코드를 한줄 한줄 읽어가면서 동작 과정을 분석해야 하고, 분기 모두를 다 따라가면서 상황에 따라 값이 어떻게 변하는 지도 관찰해야 하므로** 직관력이 부족한 개발자에게 도움이 된다.

**함수나 반복문 중간에서 할당 값을 은밀히(!) 바꾸면 훈련 강도를 좀 더 높일 수 있다.**



```javascript
function ninjaFunction(elem) {
  // 매개변수로 받아온 elem을 이용한 코드

  elem = clone(elem);

  // elem의 복제(clone)본을 이용한 코드
}
```

`elem = clone(elem);` 아래에 있는 코드를 수정하던 개발자는 아마 당신의 탁월함에 놀라움을 금치 못할 것이다. 디버깅으로 코드를 면밀히 검토한 후에서야 본인이 복제본을 이용해 작업하고 있다는 걸 깨달을 수 있다.



## [재미로 언더스코어 사용하기](https://ko.javascript.info/ninja-code#ref-1067)

`_name`이나 `__value`처럼 변수명 앞에 `_`나 `__`(언더스코어, 밑줄 표시)을 붙인다. 코드 작성자만 언더스코어가 무엇을 의미를 알게 해도 좋고, 장난으로 붙이거나 의미를 계속 바꿔가면서 붙이는 건 더 좋다.

이렇게 하면 일거양득입니다. **코드 길이가 늘어나 가독성이 떨어지는 효과가 있고, 동료 개발자들은 언더스코어의 의미를 파악하는데 오랜 시간이 소요된다.**

똑똑한 닌자라면 코드 한 영역에 밑줄 표시를 몰아서 쓰고, 다른 곳에서는 쓰지 않는 트릭을 쓰기도 한다. 이렇게 하면 코드가 에러에 취약해지는데, 다른 개발자를 훈련하기엔 이만한 방법이 없다.



## [과장 형용사 사용하기](https://ko.javascript.info/ninja-code#ref-1068)

`superElement`, `megaFrame`, `niceItem`처럼 개체 앞에 적절한 형용사를 붙여 해당 개체가 얼마나 멋진지 알려주자.

사람들은 아무 의미도 없이 붙여놓은 형용사 `super..`, `mega..`, `nice..` 등을 보고, "분명 무슨 의미가 있을 거야"라고 생각하며 눈에 쌍심지를 켜고 코드를 분석하려고 할 것이다.



## [외부 변수 덮어쓰기](https://ko.javascript.info/ninja-code#ref-1069)

> 빛 속에선 어둠을 볼 수 없고,
> 어둠 속에선 빛나는 곳에 있는 모든 것을 볼 수 있습니다.
>
> 관윤자



변수 이름을 짓는데 골머리를 썩이지 말고, 함수 내부와 외부에 동일한 이름을 가진 변수를 선언해 사용하자.

```javascript
let user = authenticateUser();

function render() {
  let user = anotherValue();
  ...
  ...함수 길이가 긺...
  ...
  ... // <-- 개발자는 user와 관련된 이 부분의 코드를 수정해야 함
  ...
}
```

함수 `render`가 긴 상황에서 user와 관련된 함수 하단부 로직만 수정해야 하는 상황이라고 해 보자. 개발자는 코드를 처음부터 읽지 않고 해당 로직이 있는 부분부터 읽을 확률이 높다. 그럼 첫 줄에서 `user`가 다시 정의되었다는 것을 놓치게 된다.

함수 내부에서 변수 `user`를 다시 정의했음에도 불구하고, 개발자는 `user`가 외부 변수(`authenticateUser()`의 호출 결과)인지 착각하며 작업을 진행할 것이다. 디버거가 나타날 타이밍이다.



## [부작용이 있는 코드 작성하기](https://ko.javascript.info/ninja-code#ref-1070)

> ❗우선, [부작용(Side Effect)과 역효과(Adverse Effect)는 전혀 다른 의미다!]
>
> > **부작용(Side Effect)**이란 원래의 용도 내지 목적의 효과는 있는데, 그와 부수적으로 다른 효과가 있는 것을 말한다. 예를 들어 진통제로 만든 약품이 탈모치료에도 효과가 있다던지, 당뇨나 비만을 가지고 있는 사람에게는 증상이 더 악화 된다던가할 때 쓰이는 말이다. 즉, 부정적인 측면만이 아닌 **당초 의도하지 않았던 결과를 발생시키는 것을 의미한다**
>
> > **역효과(Adverse Effect)** 란 붓기가 있어서 이를 가라 앉히려고 하는 목적으로 사용했지만, 오히려 염증을 더 악화시킨다던지 즉, **원래 의도했던 용도 내지 목적에 반하는 다소 부정적인 측면에서 효과가 나타나는 경우**를 의미한다.
>
> > **그렇기 때문에 프로그래밍에서도 부작용(Side Effect)이라고 해서 반드시 지양해야하는 것만은 아니기 때문에 용어정리를 잘해야한다.**



`isReady()`, `checkPermission()`, `findTags()`같은 함수들은 단순 확인용으로 사용되고 외부의 무언가를 바꾸진 않는다. "부작용"이 없는 함수들이다.

**이런 함수에 본래 기능을 넘어선 “유용한” 기능을 더해주자.**

`is..`, `check..`, `find...`등의 접두사가 붙은 함수가 무언가를 바꿀 수 있도록 기능을 더해주면 동료들에게 놀라움을 선사해줄 수 있을 겁니다. 회사에서 당신의 입지는 더 넓어진다.

**예상치 않은 결과를 반환하는 것도 한 방법이다.**

`checkPermission`이라는 함수를 호출했을 때 반환 값이 `true`나 `false`가 아니라면 좋다. 확인 여부와 다른 정보를 함께 엮어 만든 객체를 반환해 당신의 독창성을 뽐내시기 바란다.

`if (checkPermission(..))`가 왜 작동하지 않는지 물어보는 개발자에게 "문서를 읽어보세요!"라고 답하며 본 페이지를 보여주자.



## [함수에 다양한 기능 넣기](https://ko.javascript.info/ninja-code#ref-1071)

> 큰 도는 이쪽저쪽 할 것 없이 어디에나 넘쳐흐른다.
>
> 노자(도덕경)



**함수 기능을 확장하자. 함수가 할 수 있는 동작을 함수 이름에 한정 짓지 말자.**

함수 `validateEmail(email)`에 유효한 이메일 주소인지 확인해 주는 기능 이외에, 잘못된 이메일을 입력했을 때 에러 메시지를 보여준다거나 메일 주소를 다시 입력해달라는 기능을 추가하자.

함수 이름에서 유추할 수 없을 만한 기능을 추가할수록 더 좋다. 진정한 닌자라면 상상력을 발휘해 그 누구도 알 수 없을 법한 기능을 추가할 수 있을 거다.



**함수 하나에 여러 기능을 우겨 넣으면 코드 재사용도 방지할 수 있다.**

어떤 개발자가 메시지를 보여주는 기능 없이, 이메일 주소 유효성만 확인하는 기능을 구현해야 한다고 하면  **작성한 함수 `validateEmail(email)`은 두 가지 기능을 모두 하고 있기 때문에, 재사용할 수 없다는 불상사가 발생한다.** ~~재사용 자체가 불가능해지니, 질문하는 사람도 없다는 장점이 생긴다.~~



>## [요약](https://ko.javascript.info/ninja-code#ref-1072)
>
>지금까지 소개한 모든 방법은 허구가 아니다. 숙련된 개발자들도 이렇게 코드를 작성할 때가 있다. 당신보다 경력이 많은 개발자도 예외는 아니다.
>
>- 편법 중 몇 개만 사용해도, 놀라운 코드를 만들 수 있게 된다.
>- 편법을 많이 사용하면 유지 보수하기가 힘들어져서 당신을 해고할 수 없게 된다.
>- 편법을 모두 사용하면 후배 개발자들에게 엄청난 영감을 심어줄 수 있다.





#### 3.5 테스트 자동화와 Mocha

테스트 자동화는 앞으로 풀어야 할 과제에서뿐만 아니라 현업에서도 광범위하게 쓰인다.



## [테스트는 왜 해야 하는가?](https://ko.javascript.info/testing-mocha#ref-87)

함수를 하나 만들고 있다고 해 봅시다. 대부분 매개변수-결과 관계를 중심으로 어떻게 코드를 작성할지 구상할 것이다. 개발 중엔 콘솔 창 등을 이용해 실제 실행 결과가 기대했던 결과와 같은지 계속 비교하면서 원하는 기능이 잘 구현되고 있는지 확인할 것이다. 실제 실행 결과가 기대했던 결과와 다를 땐, 코드를 수정하고 다시 실행해 그 결과를 기대했던 결과와 다시 비교해 볼 것이다. 그리고 원하는 기능을 완성할 때까지 이 과정을 계속 반복할 것이다.

그런데 이렇게 수동으로 코드를 '재실행’하는 건 상당히 불완전하다.

**코드를 수동으로 ‘재실행’ 하면서 테스트를 하면 무언가를 놓치기 쉽다.**

구체적인 예를 들어보자, 현재 함수 `f`를 구현하고 있다고 가정해보면. 코드를 작성하고 `f(1)`이 제대로 동작하는지 확인하니 제대로 동작한다. 그런데 `f(2)`를 테스트해 보니 제대로 동작하지 않는다. 코드를 수정한 후 다시 `f(2)`를 확인해 보니 이번에는 제대로 동작한다. 여기서 끝일까? 아니다. `f(1)`이 제대로 동작하는지 확인하지 않았다. **이렇게 테스트를 수동으로 하면 에러가 발생할 여지를 남긴다.**

이런 일은 아주 흔히 발생한다. 개발자는 무언가를 만들 때 머릿속에 수많은 유스 케이스를 생각하며 코드를 작성하는데, 코드를 변경해야 할 때마다 모든 유스 케이스를 상기하면서 코드를 수정하는 것은 거의 불가능하다. 하나를 고치면 또 다른 문제가 튀어나오는 이유가 바로 이 때문이다.

**테스팅 자동화는 테스트 코드가 실제 동작에 관여하는 코드와 별개로 작성되었을 때 가능하다. 테스트 코드를 이용하면 함수를 다양한 조건에서 실행해 볼 수 있는데, 이때 실행 결과와 기대 결과를 비교할 수 있다.**



## [Behavior Driven Development](https://ko.javascript.info/testing-mocha#ref-88)

[Behavior Driven Development(BDD)](http://en.wikipedia.org/wiki/Behavior-driven_development)라 불리는 방법론에 대해 알아보자.

**BDD는 테스트(test), 문서(documentation), 예시(example)를 한데 모아놓은 개념이다.**

실제 개발 사례를 이용해 BDD가 무엇인지 차근차근 설명해 보도록 하겠다.



## [거듭제곱 함수와 명세서](https://ko.javascript.info/testing-mocha#ref-89)

`x`를 `n`번 곱해주는 함수, `pow(x, n)`를 구현하고 있다고 가정해 보자.(단, `n`은 자연수이고, 조건 `n≥0`을 만족해야 한다.)

사실 자바스크립트엔 거듭제곱 연산자 `**`가 있다. 그럼에도 불구하고 함수를 직접 구현하는 이유는, 기능이 간단한 함수를 구현하면서 BDD를 직접 적용해 보면 큰 문제에 BDD를 적용하는 건 쉬울 테니까 구현 과정에 초점을 두면서 BDD를 직접 적용해 보기 위해서다. 

본격적으로 코드를 작성하기 전에 먼저 해야 할 것이 있다. 코드가 무슨 일을 하는지 상상한 후 이를 자연어로 표현해야 한다.

이때, 만들어진 산출물을 BDD에선 *명세서(specification)* 또는 짧게 줄여 *스펙(spec)* 이라고 부른다. 명세서엔 아래와 같이 유스 케이스에 대한 자세한 설명과 테스트가 담겨있다.

```javascript
describe("pow", function() {

  it("주어진 숫자의 n 제곱", function() {
    assert.equal(pow(2, 3), 8);
  });

});
```

스펙은 세 가지 주요 구성 요소로 이루어진다.

- `describe("title", function() { ... })`

  구현하고자 하는 기능에 대한 설명이 들어간다. 우리 예시에선 함수 `pow`가 어떤 동작을 하는지에 대한 설명이 들어갈 겁니다. `it` 블록을 한데 모아주는 역할도 한다.

- `it("유스 케이스 설명", function() { ... })`

  `it`의 첫 번째 인수엔 특정 유스 케이스에 대한 설명이 들어간다. 이 설명은 *누구나 읽을 수 있고 이해할 수 있는 자연어*로 적어줍니다. 두 번째 인수엔 유스 케이스 테스트 함수가 들어간다.

- `assert.equal(value1, value2)`

  기능을 제대로 구현했다면 `it` 블록 내의 코드 `assert.equal(value1, value2)`이 에러 없이 실행된다.함수 `assert.*`는 `pow`가 예상한 대로 동작하는지 확인해준다. 위 예시에선 `assert.equal`이 사용되었는데, 이 함수는 인수끼리 동등 비교했을 때 다르다고 판단되면 에러를 반환한다. 예시에선 `pow(2, 3)`의 결괏값과 `8`을 비교한다. 

명세서는 실행 가능합니다. 명세서를 실행하면 `it` 블록 안의 테스트가 실행된다. 





## [개발 순서](https://ko.javascript.info/testing-mocha#ref-90)

실제 개발에 착수하면 아래와 같은 순서로 개발이 진행된다.

1. 명세서 초안을 작성합니다. 초안엔 기본적인 테스트도 들어간다.
2. 명세서 초안을 보고 코드를 작성한다.
3. 코드가 작동하는지 확인하기 위해 [Mocha](http://mochajs.org/)라 불리는 테스트 프레임워크를 사용해 명세서를 실행한다. 이때, 코드가 잘못 작성되었다면 에러가 출력된다. 개발자는 테스트를 모두 통과해 에러가 더는 출력되지 않을 때까지 코드를 수정한다.
4. 모든 테스트를 통과하는 코드 초안이 완성되었다.
5. 명세서에 지금까진 고려하지 않았던 유스케이스 몇 가지를 추가합니다. 테스트가 실패하기 시작할 것이다.
6. 세 번째 단계로 돌아가 테스트를 모두 통과할 때까지 코드를 수정한다.
7. 기능이 완성될 때까지 3~6단계를 반복한다.

명세서를 작성하고 실행한 후 테스트를 모두 통과할 때까지 코드를 작성하고, 또 다른 테스트를 추가해 앞의 과정을 반복하니까위와 같은 방법은 *반복적인(iterative)* 성격을 지닌다. 이렇게 하다 보면 종래에는 완전히 동작하는 코드와 테스트 둘 다를 확보하게 된다.

이제 실제 사례에 위 개발 프로세스를 적용해 보겠다.

함수 `pow`의 스펙 초안은 이미 위에서 작성했으므로, 첫 번째 단계는 이미 끝난 상황이다. 코드를 본격적으로 작성하기 전에 잠시 자바스크립트 라이브러리 몇 가지를 사용해 테스트를 실행해 보겠다. 지금 상태에선 테스트 모두가 실패할 텐데 그런데도 실행해 보는 이유는 테스트가 실제로 돌아가는지 확인하기 위해서다.





## [스펙 실행하기](https://ko.javascript.info/testing-mocha#ref-91)

본 튜토리얼에선 총 3개의 라이브러리를 사용해 테스트를 진행해보겠다. 각 라이브러리에 대한 설명은 아래와 같다.

- [Mocha](http://mochajs.org/) – 핵심 테스트 프레임워크로, `describe`, `it`과 같은 테스팅 함수와 테스트 실행 관련 주요 함수를 제공한다.
- [Chai](http://chaijs.com/) – 다양한 assertion을 제공해 주는 라이브러리다. 우리 예시에선 `assert.equal` 정도만 사용해 볼 예정이다.
- [Sinon](http://sinonjs.org/) – 함수의 정보를 캐내는 데 사용되는 라이브러리로, 내장 함수 등을 모방한다. 

세 라이브러리 모두, 브라우저나 서버 사이드 환경을 가리지 않고 사용 가능하다. 여기선 브라우저 환경을 가정하고 사용해 볼 것이다.

아래 HTML 페이지엔 `pow`의 스펙, 라이브러리 모두가 들어있다.

```markup
<!DOCTYPE html>
<html>
<head>
  <!-- 결과 출력에 사용되는 mocha css를 불러옵니다. -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.css">
  <!-- Mocha 프레임워크 코드를 불러옵니다. -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.js"></script>
  <script>
    mocha.setup('bdd'); // 기본 셋업
  </script>
  <!-- chai를 불러옵니다 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/3.5.0/chai.js"></script>
  <script>
    // chai의 다양한 기능 중, assert를 전역에 선언합니다.
    let assert = chai.assert;
  </script>
</head>

<body>

  <script>
    function pow(x, n) {
      /* 코드를 여기에 작성합니다. 지금은 빈칸으로 남겨두었습니다. */
    }
  </script>

  <!-- 테스트(describe, it...)가 있는 스크립트를 불러옵니다. -->
  <script src="test.js"></script>

  <!-- 테스트 결과를 id가 "mocha"인 요소에 출력하도록 합니다.-->
  <div id="mocha"></div>

  <!-- 테스트를 실행합니다! -->
  <script>
    mocha.run();
  </script>
</body>

</html>
```

위 페이지는 다섯 부분으로 나눌 수 있다.

1. `<head>` – 테스트에 필요한 서드파티 라이브러리와 스타일을 불러옴
2. `<script>` – 테스트할 함수(`pow`)의 코드가 들어감
3. 테스트 – `describe("pow", ...)`를 외부 스크립트(`test.js`)에서 불러옴
4. HTML 요소 `<div id="mocha">` – Mocha 실행 결과가 출력됨
5. `mocha.run()` – 테스트를 실행시켜주는 명령어

결과:

<iframe class="code-result__iframe" data-trusted="1" src="https://ko.js.cx/article/testing-mocha/pow-1/" style="display: block; border: 0px; width: 699px; height: 250px;"></iframe>

지금은 함수 `pow` 본문에 아무런 코드도 없기 때문에 테스트가 실패할 수밖에 없다. 지금 상황에선 `pow(2,3)`가 `8`이 아닌 `undefined`를 반환하기 때문에 에러가 발생한다.

참고로, [karma](https://karma-runner.github.io/)같은 고수준의 테스트 러너(test-runner)를 사용하면 다양한 종류의 테스트를 자동으로 실행할 수 있다.





## [코드 초안](https://ko.javascript.info/testing-mocha#ref-92)

오로지 테스트 통과만을 목적으로 코드를 간단하게 작성해보겠다.

```javascript
function pow(x, n) {
  return 8; // 속임수를 써봤습니다. :)
}
```

자, 이제 스펙을 실행해도 에러가 발생하지 않는다!

<iframe class="code-result__iframe" data-trusted="1" src="https://ko.js.cx/article/testing-mocha/pow-min/" style="display: block; border: 0px; width: 699px; height: 250px;"></iframe>





## [스펙 개선하기](https://ko.javascript.info/testing-mocha#ref-93)

지금까진 꼼수를 써서 코드를 작성했기 때문에, `pow(3,4)`를 실행하면 틀린 결과를 내뱉을 거다. 하지만 테스트는 모두 통과한다.

이렇게 테스트는 모두 통과하지만, 함수가 제 역할을 하지 못하는 경우는 실무에서 빈번하게 발생한다. 스펙이 불완전해서 그런 것이니 더 많은 유스 케이스를 추가해 보자.

`pow(3, 4) = 81`을 만족하는지 확인하는 테스트를 추가해 보겠다.

스펙에 테스트를 추가하는 방법은 아래와 같이 두 가지가 있다.

1. 기존 `it` 블록에 `assert`를 하나 더 추가하기

   ```javascript
   describe("pow", function() {
   
     it("주어진 숫자의 n 제곱", function() {
       assert.equal(pow(2, 3), 8);
       assert.equal(pow(3, 4), 81);
     });
   
   });
   ```

2. 테스트를 하나 더 추가하기(`it` 블록 하나 더 추가하기)

   ```javascript
   describe("pow", function() {
   
     it("2를 세 번 곱하면 8입니다.", function() {
       assert.equal(pow(2, 3), 8);
     });
   
     it("3을 네 번 곱하면 81입니다.", function() {
       assert.equal(pow(3, 4), 81);
     });
   
   });
   ```

`assert`에서 에러가 발생하면 `it` 블록은 즉시 종료된다. 따라서 기존 `it` 블록에 `assert`를 하나 더 추가하면 첫 번째 `assert`가 실패했을 때 두 번째 `assert`의 결과를 알 수 없습니다. 두 방법의 근본적인 차이는 여기에 있다.

두 번째 방법처럼 `it` 블록을 하나 더 추가해 테스트를 분리해서 작성하면 더 많은 정보를 얻을 수 있기 때문에 두 번째 방법을 추천한다.

여기에 더하여 테스트를 추가할 땐 다음 규칙도 따르는 게 좋다.



**테스트 하나에선 한 가지만 확인하기**

테스트 하나에서 연관이 없는 사항 두 개를 점검하고 있다면, 이 둘을 분리하는 게 좋다.

이제 두 번째 방법을 사용해 테스트를 직접 추가해보자.

결과:

<iframe class="code-result__iframe" data-trusted="1" src="https://ko.js.cx/article/testing-mocha/pow-2/" style="display: block; border: 0px; width: 699px; height: 250px;"></iframe>

두 번째 테스트가 실패했네요. `assert`에선 함수 리턴값이 `81`이 될 것이라 기대하고 있었는데, 함수는 항상 `8`을 반환하고 있기 때문에 당연히 테스트를 통과할 수 없다.



## [코드 개선하기](https://ko.javascript.info/testing-mocha#ref-94)

두 번째 테스트도 통과할 수 있게 코드를 개선해 보자. 이번엔 꼼수를 쓰지 말고 실제 우리가 구현하고자 했던 기능을 생각하면서 코드를 작성해 보자.

```javascript
function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

함수가 제대로 작동하는지 확인하기 위해 더 많은 값을 테스트해 보자. 수동으로 여러 개의 `it` 블록을 만드는 대신 `for`문을 사용해 자동으로 `it` 블록을 만들어 보자.

```javascript
describe("pow", function() {

  function makeTest(x) {
    let expected = x * x * x;
    it(`${x}을/를 세 번 곱하면 ${expected}입니다.`, function() {
      assert.equal(pow(x, 3), expected);
    });
  }

  for (let x = 1; x <= 5; x++) {
    makeTest(x);
  }

});
```

결과:

<iframe class="code-result__iframe" data-trusted="1" src="https://ko.js.cx/article/testing-mocha/pow-3/" style="display: block; border: 0px; width: 699px; height: 250px;"></iframe>

## [중첩 describe](https://ko.javascript.info/testing-mocha#ref-95)

테스트를 몇 개 더 추가해 보겠습니다. 아래 예시에서 헬퍼 함수 `makeTest`와 `for`문이 중첩 `describe` 안에 함께 묶여있다는 것을 눈여겨보시기 바다. `makeTest`는 오직 `for`문에서만 사용되고, 다른 데선 사용되지 않기 때문에 이렇게 묶어놓았다. 아래 스펙에서 `makeTest`와 `for`문은 함께 어우러져 `pow`가 제대로 동작하는지 확인해주는 역할을 한다.

이렇게 중첩 `describe`를 쓰면 그룹을 만들 수 있다.

```javascript
describe("pow", function() {

  describe("x를 세 번 곱합니다.", function() {

    function makeTest(x) {
      let expected = x * x * x;
      it(`${x}을/를 세 번 곱하면 ${expected}입니다.`, function() {
        assert.equal(pow(x, 3), expected);
      });
    }

    for (let x = 1; x <= 5; x++) {
      makeTest(x);
    }

  });

  // describe와 it을 사용해 이 아래에 더 많은 테스트를 추가할 수 있다.
});
```

중첩 `describe`는 새로운 테스트 '하위 그룹(subgroup)'을 정의할 때 사용됩니다. 이렇게 새로 정의된 테스트 하위 그룹은 테스트 결과 보고서에 들여쓰기 된 상태로 출력된다.

<iframe class="code-result__iframe" data-trusted="1" src="https://ko.js.cx/article/testing-mocha/pow-4/" style="display: block; border: 0px; width: 699px; height: 250px;"></iframe>

만약에 미래에 자체 헬퍼 함수를 가진 `it`과 `describe`를 최상위 레벨에 추가한다면, 이들 헬퍼 함수에선 `makeTest`에 접근할 수 없을 것이다.

**`before/after`와 `beforeEach/afterEach`**

함수 `before`는 (전체) 테스트가 실행되기 전에 실행되고, 함수 `after`는 (전체) 테스트가 실행된 후에 실행된다. 함수 `beforeEach`는 *매* `it`이 실행되기 전에 실행되고, 함수 `afterEach`는 *매* `it`이 실행된 후에 실행된다.

예시:

```javascript
describe("test", function() {

  before(() => alert("테스트를 시작합니다 - 테스트가 시작되기 전"));
  after(() => alert("테스트를 종료합니다 - 테스트가 종료된 후"));

  beforeEach(() => alert("단일 테스트를 시작합니다 - 각 테스트 시작 전"));
  afterEach(() => alert("단일 테스트를 종료합니다 - 각 테스트 종료 후"));

  it('test 1', () => alert(1));
  it('test 2', () => alert(2));

});
```

실행 순서는 다음과 같다.

```none
테스트를 시작합니다 - 테스트가 시작되기 전          (before)
단일 테스트를 시작합니다 - 각 테스트 시작 전         (beforeEach)
1
단일 테스트를 종료합니다 - 각 테스트 종료 후         (afterEach)
단일 테스트를 시작합니다 - 각 테스트 시작 전         (beforeEach)
2
단일 테스트를 종료합니다 - 각 테스트 종료 후         (afterEach)
테스트를 종료합니다 - 테스트가 종료된 후            (after)
```

`beforeEach/afterEach`와 `before/after`는 대개 초기화 용도로 사용됩니다. 카운터 변수를 0으로 만들거나 테스트가 바뀔 때(또는 테스트 그룹이 바뀔 때)마다 해줘야 하는 작업이 있으면 이들을 이용할 수 있다.





## [스펙 확장하기](https://ko.javascript.info/testing-mocha#ref-96)

첫 번째 반복(iteration)에선 함수 `pow`의 기본적인 기능을 구현해보았다. 그런데 아직 샴페인을 마시며 자축하긴 이르다. 또 다른 반복을 돌면서 기능을 개선해 보자.

앞서 정의했듯이 함수 `pow(x, n)`의 매개변수 `n`은 양의 정수이어야 한다.

자바스크립트에선 수학 관련 연산을 수행하다 에러가 발생하면 `NaN`을 반환한다. 함수 `pow`도 `n`이 조건에 맞지 않으면 `NaN`을 반환해야 한다.

`n`이 조건에 맞지 않을 때 함수가 `NaN`을 반환하는지 아닌지를 검사해주는 테스트를 추가해보자.

```javascript
describe("pow", function() {

  // ...

  it("n이 음수일 때 결과는 NaN입니다.", function() {
    assert.isNaN(pow(2, -1));
  });

  it("n이 정수가 아닐 때 결과는 NaN입니다.", function() {
    assert.isNaN(pow(2, 1.5));
  });

});
```

스펙을 실행하면 다음과 같은 결과가 출력된다.

<iframe class="code-result__iframe" data-trusted="1" src="https://ko.js.cx/article/testing-mocha/pow-nan/" style="display: block; border: 0px; width: 699px; height: 530px;"></iframe>

기존엔 `n`이 음수이거나 정수가 아닌 경우를 생각하지 않고 구현했기 때문에, 새롭게 추가한 테스트는 실패할 수밖에 없다. BDD의 핵심은 여기에 있다. 실패할 수밖에 없는 테스트를 추가하고, 테스트를 통과할 수 있게(에러가 발생하지 않게) 코드를 개선하는 것이다.

**다양한 assertion**

위에서 사용한 `assert.isNaN`은 `NaN`인지 아닌지를 확인해준다.

[Chai](http://chaijs.com/)는 이 외에도 다양한 assertion을 지원한다.

- `assert.equal(value1, value2)` – `value1`과 `value2`의 동등성을 확인한다(`value1 == value2`).
- `assert.strictEqual(value1, value2)` – `value1`과 `value2`의 일치성을 확인한다(`value1 === value2`).
- `assert.notEqual`, `assert.notStrictEqual` – 비 동등성, 비 일치성을 확인한다.
- `assert.isTrue(value)` – `value`가 `true`인지 확인한다(`value === true`).
- `assert.isFalse(value)` – `value`가 `false`인지 확인한다(`value === false`).
- 이 외의 다양한 assertion은 [docs](http://chaijs.com/api/assert/)에서 확인할 수 있다.

새롭게 추가한 테스트를 통과할 수 있도록 `pow`에 코드를 몇 줄 추가해보자.

```javascript
function pow(x, n) {
  if (n < 0) return NaN;
  if (Math.round(n) != n) return NaN;

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

이제 에러 없이 테스트를 모두 통과한다.

<iframe class="code-result__iframe" data-trusted="1" src="https://ko.js.cx/article/testing-mocha/pow-full/" style="display: block; border: 0px; width: 699px; height: 300px;"></iframe>



>## [요약](https://ko.javascript.info/testing-mocha#ref-97)
>
>BDD에선 스펙을 먼저 작성하고 난 후에 구현을 시작한다. 구현이 종료된 시점에는 스펙과 코드 둘 다를 확보할 수 있다.
>
>스펙의 용도는 세 가지다.
>
>1. **테스트** – 함수가 의도하는 동작을 제대로 수행하고 있는지 보장함
>2. **문서** – 함수가 어떤 동작을 수행하고 있는지 설명해줌. `describe`와 `it`에 설명이 들어감
>3. **예시** – 실제 동작하는 예시를 이용해 함수를 어떻게 사용할 수 있는지 알려줌
>
>스펙이 있기 때문에 개발자는 안전하게 함수를 개선하거나 변경할 수 있다. 함수를 처음부터 다시 작성해야 하는 경우가 생겨도 스펙이 있으면 기존 코드와 동일하게 동작한다는 것을 보장할 수 있다.
>
>코드가 바뀌어도 기존에 구현된 기능에 영향을 주지 않게 하는 건 대규모 프로젝트에서 매우 중요하다. 프로젝트 규모가 커지면 함수 하나를 이곳저곳에서 사용하는데, 수동으로 변경된 함수가 이 함수를 사용하는 모든 곳에서 제대로 동작하는지 확인하는 건 불가능하기 때문이다.
>
>테스트를 하지 않고 코드를 작성해왔다면 개발자들은 둘 중 한 갈래의 길로 빠져버리고 맙니다.
>
>1. 아무 대책 없이 코드를 변경한다. 부작용을 생각하지 않고 함수를 수정했기 때문에 어디선가 버그가 발생하고 만다.
>2. 수정이나 개선을 기피하게 된다. 코드가 구식이 되어도 그 누구도 코드를 건드리려 하지 않는다. 
>
>**테스팅 자동화는 이런 문제를 피하게 도와준다!**
>
>테스팅 자동화를 수행하고 있는 프로젝트라면 이런 문제를 걱정하지 않아도 된다. 코드에 변화가 있어도 스펙을 실행해 테스트를 진행하면 몇 초 만에 에러 발생 여부를 확인할 수 있다.
>
>장점이 하나 더 있다. **잘 테스트 된 코드는 더 나은 아키텍처를 만든다.**
>
>수정과 개선이 쉬우니까 당연히 좋은 아키텍처를 만들 수 있다고 생각할 수 있습니다. 하지만 또 다른 이유가 있다.
>
>테스트를 작성하려면 함수가 어떤 동작을 하는지, 입력값은 무엇이고 출력값은 무엇인지 정의하고 난 후에 구현을 시작한다. 코드는 정의된 사항을 뒷받침 할 수 있게 작성해야 한다. 구현을 시작하는 순간부터 이미 좋은 아키텍처가 보장된다.
>
>사실, 매번 이런 절차를 따라 구현한다는 게 쉽지만은 않다. 함수가 어떻게 동작해야 하는지 확신이 서지 않는 상황에서 코드를 작성하기도 전에 스펙을 작성해야 하므로 익숙하지 않을 수 있다. 그렇지만 테스트를 작성하면 일반적으로 개발 속도가 빨라지고 이전보다 코드를 더 안정적으로 작성할 수 있다.





#### 3.6 폴리필

자바스크립트는 끊임없이 진화하는 언어다. 새로운 제안(proposal)이 정기적으로 등록, 분석되고, 가치가 있다고 판단되는 제안은 https://tc39.github.io/ecma262/에 추가된다. 그리고 궁극적으로 [명세서(specification)](http://www.ecma-international.org/publications/standards/Ecma-262.htm)에 등록된다.

자바스크립트 엔진을 만드는 각 조직은 나름대로 우선순위를 매겨 명세서 내 어떤 기능을 먼저 구현할지 결정한다. 명세서에 등록된 기능보다 초안(draft)에 있는 제안을 먼저 구현하기로 결정하는 경우도 있다. 구현 난도가 높아서 이런 결정을 내리는 경우도 있지만, 구미를 당기지 않아 이런 결정을 내리기도 한다.

엔진이 표준 전체를 지원하지 않고 일부만 지원하는 건 흔한 일이다.

엔진별로 어떤 기능을 지원하고 있는지는 https://kangax.github.io/compat-table/es6/에서 확인할 수 있다. 





## [바벨](https://ko.javascript.info/polyfills#ref-1580)

명세서에 등록된 지 얼마 안 된 기능을 사용해 코드를 작성하다 보면 특정 엔진에서 우리가 작성한 코드를 지원하지 않는다는 걸 알게 되는 경우가 있다. 명세서 내 모든 기능을 모든 엔진이 구현하고 있지 않기 때문이다.

이럴 때 바벨을 사용할 수 있다.

**[바벨(Babel)](https://babeljs.io/)은 [트랜스파일러(transpiler)](https://en.wikipedia.org/wiki/Source-to-source_compiler)로, 모던 자바스크립트 코드를 구 표준을 준수하는 코드로 바꿔준다.**

바벨의 주요 역할은 다음과 같다.

1. 트랜스파일러 – 바벨은 코드를 재작성해주는 트랜스파일러 프로그램이다. 바벨은 개발자의 컴퓨터에서 돌아가는데, 이를 실행하면 기존 코드가 구 표준을 준수하는 코드로 변경된다. 변경된 코드는 웹사이트 형태로 사용자에게 전달된다. [웹팩(webpack)](http://webpack.github.io/)과 같은 모던 프로젝트 빌드 시스템은 코드가 수정될 때마다 자동으로 트랜스파일러를 동작시켜준다. 이런 과정이 없으면 개발이 끝난 코드를 한데 통합하는 데 어려움이 있을 수 있다.

2. 폴리필

   명세서엔 새로운 문법이나 기존에 없던 내장 함수에 대한 정의가 추가되곤 한다. 새로운 문법을 사용해 코드를 작성하면 트랜스파일러는 이를 구 표준을 준수하는 코드로 변경해준다. 반면, 새롭게 표준에 추가된 함수는 명세서 내 정의를 읽고 이에 맞게 직접 함수를 구현해야 사용할 수 있다. 자바스크립트는 매우 동적인 언어라서 원하기만 하면 어떤 함수라도 스크립트에 추가할 수 있다. 물론 기존 함수를 수정하는 것도 가능하다. 개발자는 스크립트에 새로운 함수를 추가하거나 수정해서 스크립트가 최신 표준을 준수 할 수 있게 작업할 수 있다.

   이렇게 변경된 표준을 준수할 수 있게 기존 함수의 동작 방식을 수정하거나, 새롭게 구현한 함수의 스크립트를 "폴리필(polyfill)"이라 부른다. 폴리필(poly`fill`)은 말 그대로 구현이 누락된 새로운 기능을 메꿔주는(`fill in`) 역할을 한다.

   주목할 만한 폴리필 두 가지는 아래와 같다.

   - [core js](https://github.com/zloirock/core-js) – 다양한 폴리필을 제공합니다. 특정 기능의 폴리필만 사용하는 것도 가능하다.
   - [polyfill.io](http://polyfill.io/) – 기능이나 사용자의 브라우저에 따라 폴리필 스크립트를 제공해주는 서비스이다.

모던 자바스크립트를 이용해 스크립트를 작성하려면 트랜스파일러와 폴리필은 필수이다. 또한, 모던 자바스크립트를 사용해 작성한 예시는 해당 기능을 지원하는 브라우저에서만 작동한다.

Google Chrome은 모든 브라우저 중 대개 가장 먼저 최신 기능을 지원하는데 트랜스파일러 없이 최신 기능을 사용할 수 있기 때문에 Chrome은 데모용으로 사용하기 좋다. 그런데 다른 브라우저들도 많이 뒤처지는 편은 아니니 안심하고 사용하자.

