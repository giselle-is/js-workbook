## 5.1 원시값의 메서드

자바스크립트는 원시값(문자열, 숫자 등)을 마치 객체처럼 다룰 수 있게 해준다. 원시값에도 객체에서처럼 메서드를 호출할 수 있다. 원시값의 메서드에 대해선 곧 학습할 예정인데 그 전에, 원시값은 객체가 아니란 것을 상기하도록 하자.

원시값과 객체는 다음과 같은 차이점이 있다.

**원시값**:

- 원시형 값이다.
- 원시형의 종류는 `문자(string)`, `숫자(number)`, `bigint`, `불린(boolean)`, `심볼(symbol)`, `null`, `undefined`형으로 총 일곱 가지 이다.

**객체**:

- 프로퍼티에 다양한 종류의 값을 저장할 수 있다.
- `{name : "John", age : 30}`와 같이 대괄호 `{}`를 사용해 만들 수 있다. 자바스크립트에는 여러 종류의 객체가 있는데, 함수도 객체의 일종이다.

객체의 장점 중 하나는 함수를 프로퍼티로 저장할 수 있다는 것이다.

```javascript
let john = {
  name: "John",
  sayHi: function() {
    alert("친구야 반갑다!");
  }
};

john.sayHi(); // 친구야 반갑다!
```

객체 `john`을 만들고, 거기에 메서드 `sayHi`를 정의해보았다.

자바스크립트는 날짜, 오류, HTML 요소(HTML element) 등을 다룰 수 있게 해주는 다양한 내장 객체를 제공한다. 이 객체들은 고유한 프로퍼티와 메서드를 가진다.

하지만, 이런 기능을 사용하면 시스템 자원이 많이 소모된다는 단점이 있다.

객체는 원시값보다 “무겁고”, 내부 구조를 유지하기 위해 추가 자원을 사용하기 때문이다.





#### 원시값을 객체처럼 사용하기

자바스크립트 창안자(creator)는 다음과 같은 모순적인 상황을 해결해야만 했었다.

- 문자열이나 숫자와 같은 원시값을 다루어야 하는 작업이 많은데, 메서드를 사용하면 작업을 수월하게 할 수 있을 것 같다는 생각이 든다.
- 그런데 원시값은 가능한 한 빠르고 가벼워야 한다.

조금 어색해 보이지만, 자바스크립트 창안자는 아래와 같은 방법을 사용해 해결책을 모색하였다.

1. 원시값은 원시값 그대로 남겨둬 단일 값 형태를 유지한다.
2. 문자열, 숫자, 불린, 심볼의 메서드와 프로퍼티에 접근할 수 있도록 언어 차원에서 허용한다.
3. 이를 가능하게 하기 위해, 원시값이 메서드나 프로퍼티에 접근하려 하면 추가 기능을 제공해주는 특수한 객체, "원시 래퍼 객체(object wrapper)"를 만들어 준다. 이 객체는 곧 삭제된다.

"래퍼 객체"는 원시 타입에 따라 종류가 다양하다. 각 래퍼 객체는 원시 자료형의 이름을 그대로 차용해, `String`,`Number`,`Boolean`, `Symbol`라고 부릅니다. 래퍼 객체 마다 제공하는 메서드 역시 다르다.

인수로 받은 문자열의 모든 글자를 대문자로 바꿔주는 메서드 [str.toUpperCase()](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase)를 예로 들어보자.

메서드는 아래와 같이 동작한다.

```javascript
let str = "Hello";

alert( str.toUpperCase() ); // HELLO
```

간단하죠? 아래는 `str.toUpperCase ()`가 호출될 때 내부에서 실제로 일어나는 일이다.

1. 문자열 `str`은 원시값이므로 원시값의 프로퍼티(toUpperCase)에 접근하는 순간 특별한 객체가 만들어진다. 이 객체는 문자열의 값을 알고 있고, `toUpperCase()`와 같은 유용한 메서드를 가지고 있다.
2. 메서드가 실행되고, 새로운 문자열이 반환된다(`alert` 창에 이 문자열이 출력된다).
3. 특별한 객체는 파괴되고, 원시값 `str`만 남는다.

이런 내부 프로세스를 통해 원시값을 가볍게 유지하면서 메서드를 호출할 수 있는 것이다.

자바스크립트 엔진은 위 프로세스의 최적화에 많은 신경을 쓴다. 원시 래퍼 객체를 만들지 않고도 마치 원시 래퍼 객체를 생성(명세에 언급됨)한 것처럼 동작하게끔 해준다.

숫자형도 고유한 메서드를 지원한다. 메서드 [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)를 이용하면 원하는 자리에서 소수점 아래 숫자를 반올림할 수 있다.

```javascript
let n = 1.23456;

alert( n.toFixed(2) ); // 1.23
```

[숫자형](https://ko.javascript.info/number), [문자열](https://ko.javascript.info/string)에서 더 많은 메서드에 대해 알아보자.

**`String/Number/Boolean`를 생성자론 쓰지 말자.**

Java 등의 몇몇 언어에선 `new Number(1)` 또는 `new Boolean(false)`와 같은 문법을 사용해 원하는 타입의 "래퍼 객체"를 직접 만들 수 있다.

자바스크립트에서도 하위 호환성을 위해 이 기능을 남겨 두었는데, 이런 식으로 래퍼 객체를 만드는 건 **추천하지 않는다**. 몇몇 상황에서 혼동을 불러일으키기 때문이다.



```javascript
alert( typeof 0 ); // "number"

alert( typeof new Number(0) ); // "object"!
```

객체는 논리 평가 시 항상 참을 반환하기 때문에, 아래 예시에서 얼럿창은 무조건 열린다.

```javascript
let zero = new Number(0);

if (zero) { // 변수 zero는 객체이므로, 조건문이 참이 된다.
  alert( "그런데 zero가 참이라는 것에 동의!?!" );
}
```

그런데, `new`를 붙이지 않고 `String / Number / Boolean`을 사용하는 건 괜찮다. `new` 없이 사용하면 상식에 맞게 인수를 원하는 형의 원시값(문자열, 숫자, 불린 값)으로 바꿔준다. 아주 유용하다.

예시:

```javascript
let num = Number("123"); // 문자열을 숫자로 바꿔줌
```

**`null/undefined`는 메서드가 없다.**

특수 자료형인 `null`과 `undefined`의 원시값(`null/undefined`)은 위와 같은 법칙을 따르지 않는다. 이 자료형과 연관되는 "래퍼 객체"도 없고, 메서드도 제공하지 않는다. 어떤 의미에서는 두 자료형이 "가장 원시적"이라 할 수 있을 것 같다.

두 자료형에 속한 값의 프로퍼티에 접근하려 하면 에러가 발생한다.

```javascript
alert(null.test); // error
```





> 요약
>
> - 'null’과 'undefined’를 제외한 원시값에 다양한 메서드를 호출할 수 있다. 
> - 원시값에 메서드를 호출하려 하면 임시 객체가 만들어진다. 그런데 자바스크립트 엔진은 내부 최적화가 잘 되어있어 메서드를 호출해도 많은 리소스를 쓰지 않는다.







## 5.2 숫자형

모던 자바스크립트는 숫자를 나타내는 두 가지 자료형을 지원한다.

1. 일반적인 숫자는 '배정밀도 부동소수점 숫자(double precision floating point number)'로 알려진 64비트 형식의 [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754-2008_revision)에 저장된다. 
2. 임의의 길이를 가진 정수는 BigInt 숫자로 나타낼 수 있다. 일반적인 숫자는 `253`이상이거나 `-253`이하일 수 없다는 제약 때문에 BigInt라는 새로운 자료형이 만들어졌다. BigInt는 아주 특별한 경우에만 사용되므로, 별도의 챕터 [BigInt](https://ko.javascript.info/bigint)에서 자세한 내용을 다룬다.





#### 숫자를 입력하는 다양한 방법

10억을 입력해야 한다고 상상해 보면 가장 분명한 방법은 아래와 같이 직접 10억(one billion)을 써주는 것이다.

```javascript
let billion = 1000000000;
```

그런데 이렇게 0을 많이 사용해 숫자를 표현하다 보면 잘못 입력하기 쉽기 때문에, 실제로는 이런 방법을 잘 사용하지 않는다. 0을 많이 입력하는 게 귀찮기도 하다. 그래서 대개는 10억(`billion`)을 나타낼 땐 `'1bn'`을 사용하고, 73억을 나타낼 땐 `'7.3bn'`을 사용한다. 큰 숫자를 나타낼 땐 이런 방법이 주로 사용된다.

자바스크립트에서도 숫자 옆에 `'e'`를 붙이고 0의 개수를 그 옆에 붙여주면 숫자를 줄일 수 있다.

```javascript
let billion = 1e9;  // 10억, 1과 9개의 0

alert( 7.3e9 );  // 73억 (7,300,000,000)
```

즉, `'e'`는 e 왼쪽의 수에 e 오른쪽에 있는 수만큼의 10의 거듭제곱을 곱하는 효과가 있다.

```javascript
1e3 = 1 * 1000
1.23e6 = 1.23 * 1000000
```

이제 아주 작은 숫자인 1마이크로초(백만 분의 1초)를 표현해보자.

```javascript
let ms = 0.000001;
```

작은 숫자를 표현할 때도 큰 숫자를 표현할 때처럼 `'e'`를 사용할 수 있다. 0을 명시적으로 쓰고 싶지 않다면 다음과 같이 숫자를 표현할 수 있다.

```javascript
let ms = 1e-6; // 1에서 왼쪽으로 6번 소수점 이동
```

`0.000001`에서 0의 개수를 세면 6이므로 `0.000001`은 당연히 `1e-6`이 된다.

이렇게 `'e'` 우측에 음수가 있으면, 이 음수의 절댓값 만큼 10을 거듭제곱한 수로 나누는 것을 의미한다.

```javascript
// 10을 세 번 거듭제곱한 수로 나눔
1e-3 = 1 / 1000 (=0.001)

// 10을 여섯 번 거듭제곱한 수로 나눔
1.23e-6 = 1.23 / 1000000 (=0.00000123)
```





#### 16진수, 2진수, 8진수

[16진수](https://en.wikipedia.org/wiki/Hexadecimal)는 색을 나타내거나 문자를 인코딩할 때 등 다양한 곳에서 두루 쓰인다. 다양한 곳에서 쓰이는 만큼 당연히 16진수를 짧게 표현하는 방법도 존재하는데, 16진수는 `0x`를 사용해 표현할 수 있다.

```javascript
alert( 0xff ); // 255
alert( 0xFF ); // 255 (대·소문자를 가리지 않으므로 둘 다 같은 값을 나타낸다.)
```



2진수와 8진수는 아주 드물게 쓰이긴 하지만, 접두사 `0b`와 `0o`를 사용해 간단히 나타낼 수 있다.

```javascript
let a = 0b11111111; // 255의 2진수
let b = 0o377; // 255의 8진수

alert( a == b ); // true, 진법은 다르지만, a와 b는 같은 수임
```

자바스크립트에서 지원하는 진법은 3개이다. 이 외의 진법을 사용하려면 함수 `parseInt`를 사용해야 한다(챕터 후반부에서 다룸).





#### toString(base)

`num.toString(base)` 메서드는 `base`진법으로 `num`을 표현한 후, 이를 문자형으로 변환해 반환한다.

```javascript
let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
```

`base`는 `2`에서 `36`까지 쓸 수 있는데, 기본값은 `10` 이다.

`base`별 유스 케이스는 다음과 같다.

- **base=16** – 16진수 색, 문자 인코딩 등을 표현할 때 사용한다. 숫자는 `0`부터 `9`, 10 이상의 수는 `A`부터 `F`를 사용하여 나타낸다.

- **base=2** – 비트 연산 디버깅에 주로 쓰인다. 숫자는 `0` 또는 `1`이 될 수 있다.

- **base=36** – 사용할 수 있는 `base` 중 최댓값으로, `0..9`와 `A..Z`를 사용해 숫자를 표현한다. 알파벳 전체가 숫자를 나타내는 데 사용된다. `36` 베이스는 url을 줄이는 것과 같이 숫자로 된 긴 식별자를 짧게 줄일 때 유용하다. 

  ```javascript
  alert( 123456..toString(36) ); // 2n9c
  ```

**점 두 개와 메서드 호출**

`123456..toString(36)`에 있는 점 두 개는 오타가 아니다. 위 예시처럼 숫자를 대상으로 메서드 `toString`을 직접 호출하고 싶다면 숫자 다음에 점 두 개 `..`를 붙여야 한다.

`123456.toString(36)`처럼 점을 한 개만 사용하면, 첫 번째 점 이후는 소수부로 인식되어 에러가 발생할 수 있다. 점을 하나 더 추가하면 자바스크립트는 소수부가 없다고 판단하고 함수를 호출한다.

`(123456).toString(36)`도 가능하다.





#### 어림수 구하기

어림수를 구하는 것(rounding)은 숫자를 다룰 때 가장 많이 사용되는 연산 중 하나이다.

어림수 관련 내장 함수 몇 가지를 살펴보자.

- `Math.floor`

  소수점 첫째 자리에서 내림(버림). `3.1`은 `3`, `-1.1`은 `-2`가 된다.

- `Math.ceil`

  소수점 첫째 자리에서 올림. `3.1`은 `4`, `-1.1`은 `-1`이 된다.

- `Math.round`

  소수점 첫째 자리에서 반올림. `3.1`은 `3`, `3.6`은 `4`, `-1.1`은 `-1`이 된다.

- `Math.trunc` (Internet Explorer에서는 지원하지 않음)

  소수부를 무시. `3.1`은 `3`이 되고 `-1.1`은 `-1`이 된다.

  

각 내장 함수의 차이를 표로 나타내면 다음과 같다.

|        | `Math.floor` | `Math.ceil` | `Math.round` | `Math.trunc` |
| :----- | :----------- | :---------- | :----------- | :----------- |
| `3.1`  | `3`          | `4`         | `3`          | `3`          |
| `3.6`  | `3`          | `4`         | `4`          | `3`          |
| `-1.1` | `-2`         | `-1`        | `-1`         | `-1`         |
| `-1.6` | `-2`         | `-1`        | `-2`         | `-1`         |

위에서 소개한 내장 함수들만으로도 소수부에 관련된 연산 대부분을 처리할 수 있다. 그런데 소수점 `n-th`번째 수를 기준으로 어림수를 구해야 하는 상황이라면 어떻게 해야 할까?

예를 들어 `1.2345`가 있는데 소수점 두 번째 자릿수까지만 남겨 `1.23`을 만들고 싶은 경우처럼 말이다.

두 가지 방법이 있다.

1. 곱하기와 나누기

   소수점 두 번째 자리 숫자까지만 남기고 싶은 경우, 숫자에 `100` 또는 `100`보다 큰 `10`의 거듭제곱 수를 곱한 후, 원하는 어림수 내장 함수를 호출하고 처음 곱한 수를 다시 나누면 된다.

   ```javascript
   let num = 1.23456;
   
   alert( Math.floor(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
   ```

2. 소수점 `n` 번째 수까지의 어림수를 구한 후 이를 문자형으로 반환해주는 메서드인 [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)를 사용한다.

   ```javascript
   let num = 12.34;
   alert( num.toFixed(1) ); // "12.3"
   ```

   `toFixed`는 `Math.round`와 유사하게 가장 가까운 값으로 올림 혹은 버림해준다.

   ```javascript
   let num = 12.36;
   alert( num.toFixed(1) ); // "12.4"
   ```

   `toFixed`를 사용할 때 주의할 점은 이 메서드의 반환 값이 문자열이라는 것이다. 소수부의 길이가 인수보다 작으면 끝에 0이 추가된다.

   ```javascript
   let num = 12.34;
   alert( num.toFixed(5) ); // "12.34000", 소수부의 길이를 5로 만들기 위해 0이 추가되었다.
   ```

   참고로, `+num.toFixed(5)`처럼 단항 덧셈 연산자를 앞에 붙이거나 `Number()`를 호출하면 문자형의 숫자를 숫자형으로 변환할 수 있다.





#### 부정확한 계산

숫자는 내부적으로 64비트 형식 [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754-2008_revision)으로 표현되기 때문에 숫자를 저장하려면 정확히 64비트가 필요하다. 64비트 중 52비트는 숫자를 저장하는 데 사용되고, 11비트는 소수점 위치를(정수는 0), 1비트는 부호를 저장하는 데 사용된다.

그런데 숫자가 너무 커지면 64비트 공간이 넘쳐서 Infinity로 처리된다.

```javascript
alert( 1e500 ); // Infinity
```



원인을 이해하려면 집중이 필요하긴 하지만, 꽤 자주 발생하는 현상인 정밀도 손실(loss of precision)도 있다.

```javascript
alert( 0.1 + 0.2 == 0.3 ); // false
```

`0.1`과 `0.2`의 합이 `0.3`과 일치하는지 확인 했는데 `false`가 출력되었다.



합의 결과가 `0.3`이 아니라면 대체 무엇일까?

```javascript
alert( 0.1 + 0.2 ); // 0.30000000000000004
```



부정확한 비교 연산이 만들어내는 결과는 여기서 그치지 않는다. 인터넷 쇼핑몰 사이트를 운영하고 있다고 가정해 보면, 사용자가 `$0.10`와 `$0.20` 짜리 물품을 장바구니에 넣었다고 상상해 본다. 주문 총액이 `$0.30000000000000004`인 것을 보고 놀라지 않을 사용자는 없을 것이다.

왜 이런 일이 발생하는 걸까?

숫자는 0과 1로 이루어진 이진수로 변환되어 연속된 메모리 공간에 저장된다. 그런데 10진법을 사용하면 쉽게 표현할 수 있는 `0.1`, `0.2` 같은 분수는 이진법으로 표현하면 무한 소수가 된다.

`0.1`은 1을 10으로 나눈 수인 `1/10` 이다. 10진법을 사용하면 이러한 숫자를 쉽게 표현할 수 있다. `1/10`과 `1/3`을 비교해보자. `1/3`은 무한 소수 `0.33333(3)`이 된다.

이렇게 `10`의 거듭제곱으로 나눈 값은 10진법에서 잘 동작하지만 `3`으로 나누게 되면 10진법에서 제대로 동작하지 않는다. 같은 이유로 2진법 체계에서 `2`의 거듭제곱으로 나눈 값은 잘 동작하지만 `1/10`같이 `2`의 거듭제곱이 아닌 값으로 나누게 되면 무한 소수가 되어버린다.

10진법에서 1/3을 정확히 나타낼 수 없듯이, 2진법을 사용해 *0.1* 또는 *0.2*를 **정확하게** 저장하는 방법은 없다.

IEEE-754에선 가능한 가장 가까운 숫자로 반올림하는 방법을 사용해 이런 문제를 해결한다. 그런데 반올림 규칙을 적용하면 발생하는 '작은 정밀도 손실’을 우리가 볼 수는 없지만 실제로 손실은 발생한다.

아래와 같이 코드를 작성하면 정밀도 손실을 눈으로 확인할 수 있다.

```javascript
alert( 0.1.toFixed(20) ); // 0.10000000000000000555
```

그리고 두 숫자를 합하면 '정밀도 손실’도 더해진다.

`0.1 + 0.2`가 정확히 `0.3`이 아닌 이유가 여기에 있다.

**자바스크립트뿐만이 아니다.**

다른 언어에서도 같은 이슈가 있다.

자바스크립트와 동일한 숫자 형식을 사용하기 때문에 PHP, Java, C, Perl, Ruby에서도 똑같은 결과를 얻는다.

문제를 해결하는 방법은 없을까? 물론 있다. 가장 신뢰할만한 방법은 [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)메서드를 사용해 어림수를 만드는 것이다.

```javascript
let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // 0.30
```

이때 `toFixed`는 항상 문자열을 반환한다는 점에 유의해야 한다. 문자열을 반환하기 때문에 소수점 다음에 오는 숫자가 항상 2개가 될 수 있다. 인터넷 쇼핑몰을 구축 중이고 `$0.30`를 보여줘야 할 때 유용하다. 문자형으로 바뀐 숫자를 다시 숫자형으로 강제 변환하려면 단항 덧셈 연산자를 사용하면 된다.

```javascript
let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3
```

숫자에 임시로 100(또는 더 큰 숫자)을 곱하여 정수로 바꾸고, 원하는 연산을 한 후 다시 100으로 나누는 것도 하나의 방법이 될 수 있다. 정수를 대상으로 하는 수학 연산은 소수를 대상으로 하는 연산보다 에러가 적기 때문이다. 그런데 어쨌든 마지막에 나눗셈이 들어가기 때문에 소수가 다시 등장할 수 있다는 단점이 있다.

```javascript
alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
```

이렇게 10의 거듭제곱을 곱하고 다시 동일한 숫자로 나누는 전략은 오류를 줄여주긴 하지만 완전히 없애지는 못한다.

구현을 하다 보면 무한 소수가 나오는 경우를 완전히 차단해야 하는 경우가 생기곤 한다. 달러가 아닌 센트 단위로 물품 가격을 저장하는 쇼핑몰을 담당하고 있는데, 행사 때문에 가격을 30% 할인해야 하는 경우가 그렇다. 무한소수를 방지하는 완벽한 방법은 사실 없다. 필요할 때마다 '꼬리’를 잘라 어림수를 만드는 방법뿐이다.



**흥미로운 발견**

```javascript
// 숫자가 스스로 증가한다!
alert( 9999999999999999 ); // 10000000000000000이 출력된다.
```

문제의 원인은 역시나 정밀도 손실 때문이다. 숫자를 저장할 땐 64비트가 사용되는데, 이 중 실제 숫자를 저장하는 데 사용되는 52비트에 위 숫자를 저장하기엔 공간이 모자란다. 따라서 최소 유효 숫자(the least significant digit)가 손실되어 버렸다.

자바스크립트는 숫자 손실이 일어나도 오류를 발생시키지 않는다. 적절한 포맷으로 숫자를 맞추는 데 최선을 다하긴 하지만 유감스럽게도 위 예시의 숫자를 담기엔 포맷이 충분하지 못한다.

**두 종류의 0**

자바스크립트 내부에서 숫자를 표현하는 방식 때문에 발생하는 또 다른 흥미로운 현상은 `0`과 `-0`이라는 두 종류의 0이 존재한다는 사실이다. 자바스크립트에선 숫자의 부호가 단일 비트에 저장되는데 0을 포함한 모든 숫자에 부호를 설정할 수도, 설정하지 않을 수도 있기 때문이다.

하지만, 대부분의 연산은 `0`과 `-0`을 동일하게 취급하기 때문에 두 0의 차이는 두드러지지 않는 편이다.



#### isNaN과 isFinite

- `Infinity`와 `-Infinity` – 그 어떤 숫자보다 큰 혹은 작은 특수 숫자 값
- `NaN` – 에러를 나타내는 값

두 특수 숫자는 `숫자형`에 속하지만 ‘정상적인’ 숫자는 아니기 때문에, 정상적인 숫자와 구분하기 위한 특별한 함수가 존재한다.

- `isNaN(value)` – 인수를 숫자로 변환한 다음 `NaN`인지 테스트함

  ```javascript
  alert( isNaN(NaN) ); // true
  alert( isNaN("str") ); // true
  ```

  그런데 굳이 이 함수가 필요할까? "`=== NaN` 비교를 하면 되지 않을까?"라는 생각이 들 수 있다. 안타깝게도 대답은 '필요하다’이다. `NaN`은 `NaN` 자기 자신을 포함하여 그 어떤 값과도 같지 않다는 점에서 독특하다.

  ```javascript
  alert( NaN === NaN ); // false
  ```

- `isFinite(value)` – 인수를 숫자로 변환하고 변환한 숫자가 `NaN/Infinity/-Infinity`가 아닌 일반 숫자인 경우 `true`를 반환함

  ```javascript
  alert( isFinite("15") ); // true
  alert( isFinite("str") ); // false, NaN이기 때문이다.
  alert( isFinite(Infinity) ); // false, Infinity이기 때문이다.
  ```

`isFinite`는 문자열이 일반 숫자인지 검증하는 데 사용되곤 한다.

```javascript
let num = +prompt("숫자를 입력하세요.", '');

// 숫자가 아닌 값을 입력하거나 Infinity, -Infinity를 입력하면 false가 출력된다.
alert( isFinite(num) );
```

빈 문자열이나 공백만 있는 문자열은 `isFinite`를 포함한 모든 숫자 관련 내장 함수에서 `0`으로 취급된다는 점에 유의하자.



> **`Object.is`와 비교하기**
>
> `Object.is` 는 `===`처럼 값을 비교할 때 사용되는 특별한 내장 메서드인데, 아래와 같은 두 가지 에지 케이스에선 `===`보다 좀 더 신뢰할만한 결과를 보여준다.
>
> 1. `Na다ㄴ`을 대상으로 비교할 때: `Object.is(NaN, NaN) === true`임.
> 2. `0`과 `-0`이 다르게 취급되어야 할 때: `Object.is(0, -0) === false`임. 숫자를 나타내는 비트가 모두 0이더라도 부호를 나타내는 비트는 다르므로 `0`과 `-0`은 사실 다른 값이긴 한다.
>
> 이 두 에지 케이스를 제외하곤, `Object.is(a, b)`와 `a === b`의 결과는 같다.
>
> 이런 식의 비교는 자바스크립트 명세서에서 종종 찾아볼 수 있다. 내부 알고리즘에서 두 값을 비교해야 하는데, 비교 결과가 정확해야 하는 경우 `Object.is`를 사용한다. `Object.is`에서 사용되는 비교방식은 명세서에서 [SameValue](https://tc39.github.io/ecma262/#sec-samevalue)라고 불린다.





#### parseInt와 parseFloat

단항 덧셈 연산자 `+` 또는 `Number()`를 사용하여 숫자형으로 변형할 때 적용되는 규칙은 꽤 엄격하다. 피연산자가 숫자가 아니면 형 변환이 실패한다.

```javascript
alert( +"100px" ); // NaN
```

엄격한 규칙이 적용되지 않는 유일한 예외는 문자열의 처음 또는 끝에 공백이 있어서 공백을 무시할 때이다.

그런데 실무에선 CSS 등에서 `'100px'`, `'12pt'`와 같이 숫자와 단위를 함께 쓰는 경우가 흔하다. 대다수 국가에서 `'19€'`처럼 금액 뒤에 통화 기호를 붙여 표시하기도 하죠. 숫자만 추출하는 방법이 필요해 보인다.

내장 함수 `parseInt`와 `parseFloat`는 이런 경우를 위해 만들어졌다.

두 함수는 불가능할 때까지 문자열에서 숫자를 ‘읽습니다’. 숫자를 읽는 도중 오류가 발생하면 이미 수집된 숫자를 반환한다. `parseInt`는 정수, `parseFloat`는 부동 소수점 숫자를 반환한다.

```javascript
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, 정수 부분만 반환됩니다.
alert( parseFloat('12.3.4') ); // 12.3, 두 번째 점에서 숫자 읽기를 멈춘다.
```

`parseInt`와 `parseFloat`가 `NaN`을 반환할 때도 있습니다. 읽을 수 있는 숫자가 없을 때 그렇다.

```javascript
alert( parseInt('a123') ); // NaN, a는 숫자가 아니므로 숫자를 읽는 게 중지된다.
```

**`parseInt(str, radix)`의 두 번째 인수**

`parseInt()`의 두 번째 매개 변수는 선택적으로 사용할 수 있다. `radix`는 원하는 진수를 지정해 줄 때 사용한다. 따라서 `parseInt`를 사용하면 16진수 문자열, 2진수 문자열 등을 파싱할 수 있다.

```javascript
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, 0x가 없어도 동작한다.

alert( parseInt('2n9c', 36) ); // 123456
```





#### 기타 수학 함수

자바스크립트에서 제공하는 내장 객체 [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math)엔 다양한 수학 관련 함수와 상수들이 들어있다.

몇 가지 예시를 살펴보자.

- `Math.random()`

  0과 1 사이의 난수를 반환한다(1은 제외).`alert( Math.random() ); // 0.1234567894322 alert( Math.random() ); // 0.5435252343232 alert( Math.random() ); // ... (무작위 수)`

- `Math.max(a, b, c...)` / `Math.min(a, b, c...)`

  인수 중 최대/최솟값을 반환한다.`alert( Math.max(3, 5, -10, 0, 1) ); // 5 alert( Math.min(1, 2) ); // 1`

- `Math.pow(n, power)`

  `n`을 power번 거듭제곱한 값을 반환한다.`alert( Math.pow(2, 10) ); // 2의 10제곱 = 1024`

이 외에도 삼각법을 포함한 다양한 함수와 상수가 `Math`에 있다. 



>#### 요약
>
>0이 많이 붙은 큰 숫자는 다음과 같은 방법을 사용해 쓴다.
>
>- 0의 개수를 `'e'` 뒤에 추가한다. `123e6`은 0이 6개인 숫자, `123000000`을 나타낸다.
>- `'e'` 다음에 음수가 오면, 음수의 절댓값 만큼 10을 거듭제곱한 숫자로 주어진 숫자를 나눈다. `123e-6`은 `0.000123`을 나타낸다.
>
>다양한 진법을 사용할 수도 있다.
>
>- 자바스크립트는 특별한 변환 없이 16진수(`0x`), 8진수(`0o`), 2진수(`0b`)를 바로 사용할 수 있게 지원한다.
>- `parseInt(str, base)`를 사용하면 `str`을 `base`진수로 바꿔준다(단, `2 ≤ base ≤ 36`).
>- `num.toString(base)`는 숫자를 `base`진수로 바꾸고, 이를 문자열 형태로 반환한다.
>
>`12pt`나 `100px`과 같은 값을 숫자로 변환하는 것도 가능하다.
>
>- `parseInt/parseFloat`를 사용하면 문자열에서 숫자만 읽고, 읽은 숫자를 에러가 발생하기 전에 반환해주는 ‘약한’ 형 변환을 사용할 수 있다.
>
>소수를 처리하는 데 쓰이는 메서드는 다음과 같다.
>
>- `Math.floor`, `Math.ceil`, `Math.trunc`, `Math.round`, `num.toFixed(precision)`를 사용하면 어림수를 구할 수 있다.
>- 소수를 다룰 땐 정밀도 손실에 주의해야한다.
>
>이 외에도 다양한 수학 함수가 있다.
>
>- 수학 연산이 필요할 때 [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) 객체를 찾아보자. 작은 객체이지만 기본적인 연산은 대부분 다룰 수 있다.

